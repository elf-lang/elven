InitWindow("DSP", 256, 128, 3)

TAU ::= 6.283185307179586

signal = {}

lerp = fun(a, b, t) ? {
	--> a + (b - a) * t
}

for i = 0...256 ? {
	// random
	s := 0

	// s += (elf.random() * 2 - 1)

	// high frequency
	// s += sin((i / 32.0) * TAU)
	// s += sin((i / 8.0) * TAU)

	// square
	s += ((i % 32 < 16) * 2 - 1)

	signal:add(s * 32)
}

Delay_Line = {
	__new = fun(capacity) {
		this.capacity = capacity
		//
		this.buffer = {}
		for i = 0...capacity ? {
			this.buffer:add(0)
		}
		this.write_index = 0
	}

	read = fun(delay) ? {
		index := (this.write_index - delay + this.capacity) % this.capacity
		value := this.buffer:idx(index)
		--> value
	}

	store = fun(value) ? {
		this.write_index %= this.capacity
		this.buffer:xset(this.write_index, value)
		this.write_index += 1
	}
}

// dl := new Delay_Line(4)
// dl:store(1)
// // dl:store(2)
// // dl:store(3)
// // dl:store(4)

// elf.pf(dl.buffer)


ADSR_Envelope = {
	__new = fun() ? {
		this.attack_time   = attack
		this.decay_time    = decay
		this.sustain       = sustain
		this.release_time  = release
	}

	evaluateContinuos = fun(time) ? {

		if time <= this.attack_time ? {
			--> time / this.attack_time
		}

		time -= this.attack_time
		if time < this.decay_time ? {
			--> lerp(1, this.sustain, time / this.decay_time)
		}

		time -= this.decay_time
		if time < this.release_time ? {
			--> lerp(this.sustain, 0, time / this.release_time)
		}

		--> 0
	}
}


LPF_MetaClass = {
	{
		name = "responsiveness",
		min  = 0,
		max  = 1,
		getter = fun(instance) ? { --> instance:getResponsiveness() }
		setter = fun(instance, value) ? { instance:setResponsiveness(value) }
	}
}

BPF_MetaClass = {
	{
		name = "lpf_responsiveness",
		min  = 0,
		max  = 1,
		getter = fun(instance) ? { --> instance.lpf:getResponsiveness() }
		setter = fun(instance, value) ? { instance.lpf:setResponsiveness(value) }
	},
	{
		name = "hpf_responsiveness",
		min  = 0,
		max  = 1,
		getter = fun(instance) ? { --> instance.hpf:getResponsiveness() }
		setter = fun(instance, value) ? { instance.hpf:setResponsiveness(value) }
	}
}

LowPassFilter = {
	metaclass = LPF_MetaClass

	__new = fun() ? {
		this.responsiveness = 1.0
		// - internal state
		this.output = 0
	}

	getResponsiveness = fun() ? {
		--> this.responsiveness
	}
	setResponsiveness = fun(responsiveness) ? {
		this.responsiveness = responsiveness
	}

	filter = fun(input) ? {
		output := this.output * (1.0 - this.responsiveness) + input * this.responsiveness
		this.output = output
		--> output
	}
}

HighPassFilter = {
	metaclass = LPF_MetaClass

	__new = fun() ? {
		this.responsiveness = 1.0
		// - internal state
		this.output = 0
		this.input = 0
	}

	getResponsiveness = fun() ? {
		--> this.responsiveness
	}
	setResponsiveness = fun(responsiveness) ? {
		this.responsiveness = responsiveness
	}

	filter = fun(input) ? {
		output := this.responsiveness * (this.output + input - this.input)
		this.output = output
		this.input = input
		--> output
	}
}

BandPassFilter = {
	metaclass = BPF_MetaClass

	__new = fun() ? {
		this.hpf = new HighPassFilter()
		this.lpf = new  LowPassFilter()
	}

	getResponsiveness = fun() ? {
		--> this.hpf:getResponsiveness()
	}
	setResponsiveness = fun(responsiveness) ? {
		this.hpf:setResponsiveness(responsiveness)
		this.lpf:setResponsiveness(responsiveness)
	}

	filter = fun(input) ? {
		output := this.hpf:filter(input)
		output  = this.lpf:filter(output)
		--> output
	}
}

filters := {
	new LowPassFilter(),
	new HighPassFilter(),
	new BandPassFilter(),
}


while PollWindow() ? {
	Clear(32, 32, 32, 255)
	SetColor(255, 255, 255, 255)

	// DrawRectangle(0, 0, 32, 32)

	y := 64
	DrawLine(0, y, 256, y)

	SetColor(255, 255, 255, 255)
	for x = 0...256 ? {
		s := signal:idx(x)
		DrawLine(x, y, x, y + s)
	}

	for i = 0...3 ? {
		if Button('1' + i) & 4 ? {
			elf.pf("Selected Filter: ", i)
			instance = filters:idx(i)
			parameter = nil
		}
	}
	instance ?= filters:idx(0)
	parameter ?= nil

	buttons := { 'Q', 'W' }
	for i = 0...2 ? {
		if Button(buttons:idx(i)) & 4 ? {
			parameter = instance:metaclass:idx(i)
			elf.pf("Selected Parameter: ", parameter.name)
		}
	}
	if parameter ? {
		value := parameter.getter(instance)
		if Button('A') & 1 ? {
			value -= 0.01
		}
		if Button('D') & 1 ? {
			value += 0.01
		}
		if value > parameter.max ? {
			value = parameter.max
		} else if value < parameter.min ? {
			value = parameter.min
		}

		parameter.setter(instance, value)
	}


	SetColor(0, 255, 0, 128)
	for x = 0...256 ? {
		s := instance:filter(signal:idx(x))
		DrawLine(x, y, x, y + s)
	}
}