// elf.change_work_dir("W:\\MicroRJ\\platformer")
// load "main.elf"
elf.include("elf.kit")
.create("launch",128,128)


let TIME = 1.0 / 144.0
total_time = 0

draw_circ = fun(x,y,r) ? {
	.draw_rect(x-r,y-r,r*2,r*2,255,255,255,255)
}
apply_force = fun(p,x,y) ? {
	p.vx += x
	p.vy += y
}
get_perp = fun(dx,dy) ? {
	let p_x = - dy
	let p_y = + dx
	let l = sqrt(p_x*p_x + p_y*p_y)
	p_x /= l
	p_y /= l
	leave {x=p_x,y=p_y}
}
physics_tick = fun(p,time) ? {
	p.x += p.vx * time
	p.y += p.vy * time
	p.vx -= p.vx * 2.0 * time
	p.vy -= p.vy * 2.0 * time
}
get_dir = fun(dst,src) ? {
	let sx = dst.x - src.x
	let sy = dst.y - src.y
	let l = sqrt(sx*sx + sy*sy)
	if l ? {
		let dx = sx / l
		let dy = sy / l
		leave {x=dx,y=dy}
	} else {
		leave {x=0,y=0}
	}
}
get_dist = fun(dst,src) ? {
	let sx = dst.x - src.x
	let sy = dst.y - src.y
	let l = sqrt(sx*sx + sy*sy)
	leave l
}
apply_stick_force = fun(a,b,c,bias) ? {
	bias ?= 0.5
	let l = get_dist(a,b)
	let d = get_dir(a,b)
	let p = c - l
	a:apply_force(d.x*p*+bias,d.y*p*+bias)
	b:apply_force(d.x*p*-(1.0 - bias),d.y*p*-(1.0 - bias))
}

get_weave_towards_force = fun(src,dst) ? {
	let phase = total_time * 3.14
	let d = get_dir(dst,src)

	let perp = get_perp(d.x,d.y)
	let weave = 0
	weave += sin(phase * 1) * 1.4
	// weave += sin(phase * 3) * 1.1

	let force = {}
	force.x = d.x + perp.x*weave
	force.y = d.y + perp.y*weave

	leave force
}

stick = apply_stick_force

fun(a,b,c) ? {
	let l = get_dist(a,b)
	let d = get_dir(a,b)
	let p = c - l
	if p < 0 ? {
		let h = p * 0.5
		iff a.pin ? {
			// apply_force(a
			// , d.x * h * 4
			// , d.y * h * 4)
			a.x += d.x * h
			a.y += d.y * h
		}
		iff b.pin ? {
			// apply_force(a
			// , - d.x * h * 4
			// , - d.y * h * 4)
			b.x -= d.x * h
			b.y -= d.y * h
		}
	}
}
get_move_force = fun() ? {
	let movex = .is_key_down('D') - .is_key_down('A')
	let movey = .is_key_down('S') - .is_key_down('W')
	leave {x=movex,y=movey}
}
Particle = {
	__new = fun(x,y) ? {
		this.x = x
		this.y = y
		this.vx = vx
		this.vy = vy
		this.pin = false
	}
	apply_force = fun(x,y) ? {
		iff this.pin ? {
			apply_force(this,x,y)
		}
	}
	tick = fun(time) ? {
		physics_tick(this,time)
	}
	draw = fun() ? {
		draw_circ(this.x,this.y,3,3, 255,255,255,255)
	}
}
Tentacle = Particle:merge {
	__new = fun(x,y) ? {
		this.segs = {}
		this.x = x
		this.y = y
		this.vx = 0
		this.vy = 0
		this.planted = false
		for i = 0...5 ? {
			this.segs:add(new Particle(i*6,0))
		}
		this.segs:idx(-1).pin = true
		this.segs:idx(-1).x = x
		this.segs:idx(-1).y = y
	}
	// set_pos = fun(pos) ? {
	// 	this.segs:idx(0).x = pos.x
	// 	this.segs:idx(0).y = pos.y
	// }
	tick = fun(time) ? {
		let p = this.segs:idx(-1)

		// physics_tick(p,time)

		// for k = 0...2 ? {
		let segs = this.segs
		let nsegs = segs:tally()
		let p = segs:idx(nsegs-1)
		for i = 1...nsegs ? {
			let c = segs:idx(nsegs-1-i)
			apply_stick_force(c,p,6)
				// let dir = get_dir(p,c)
				// c.x = p.x - dir.x * 6
				// c.y = p.y - dir.y * 6
			p = c
		}
		// }

		for i = 0...this.segs:tally() ? {
			this.segs:idx(i):tick(time)
		}
	}
	draw = fun() ? {
		for i = 0...this.segs:tally() ? {
			this.segs:idx(i):draw()
		}
	}
}
Monster = {
	__new = fun(x,y) ? {
		this.x=x ?? 64
		this.y=y ?? 64
		this.r=8

		this.top_tentacle = new Tentacle(0,0)
		this.bottom_tentacle = new Tentacle(0,0)
		this.left_tentacle = new Tentacle(0,0)
		this.right_tentacle = new Tentacle(0,0)
		this.tentacles = {}
		// this.tentacles:add(
		// this.top_tentacle,this.bottom_tentacle,
		// this.left_tentacle,this.right_tentacle,
		// )
	}
	apply_force = fun(x,y) ? {
		apply_force(this,x,y)
	}
	draw = fun() ? {
		for i = 0...this.tentacles:tally() ? {
			this.tentacles:idx(i):draw()
		}
		draw_circ(this.x,this.y,this.r)
	}
	tick = fun(time) ? {
		// this.tentacles:idx(0).segs:idx(-1).pin = true
		// this.tentacles:idx(0).segs:idx(-1).x = 64
		// this.tentacles:idx(0).segs:idx(-1).y = 64
		let move = get_move_force()
		apply_force(this,move.x*2,move.y*2)
		physics_tick(this,time)
		for i = 0...this.tentacles:tally() ? {
			this.tentacles:idx(i):set_pos(this)
			this.tentacles:idx(i):tick(time)
			stick(this,this.tentacles:idx(i).segs:idx(0),1)
		}
	}
}

mon = new Monster(64,64)

let p0 = new Particle(64,64)
let p1 = new Particle(64+10,64)

let tent = new Tentacle(64,64)

while .step() ? {
	// p0.pin = true
	// apply_stick_force(p0, p1,6,0.50)
	// apply_stick_force(p1,mon,6,0.50)

	apply_stick_force(tent.segs:idx(0),mon,6,0.50)

	// let weave = get_weave_towards_force(mon, .get_mouse_pos())
	// mon:apply_force(weave.x,weave.y)

	tent:tick(TIME)
	// p0:tick(TIME)
	// p1:tick(TIME)
	mon:tick(TIME)

	tent:draw()
	// p0:draw()
	// p1:draw()
	mon:draw()
	total_time += TIME
}