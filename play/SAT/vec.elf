PI		= 3.14159
TAU 	= 6.28318
TODEG = 1.0 / PI * 180.0

abs = fun(x,y) ? { if x < 0 ? --> -x else --> x }
min = fun(x,y) ? { if x < y ? -->  x else --> y }
max = fun(x,y) ? { if x > y ? -->  x else --> y }

trim = fun(x,min,max) ? {
	if x < min ? --> min
	if x > max ? --> max
	--> x
}

trim01 = fun(x) ? {
	if x < 0.0 ? --> 0.0
	if x > 1.0 ? --> 1.0
	--> x
}

lerp = fun(x,y,z) ? (y + x * (z - y))
unlerp = fun(x,y,z) ? ((x - y) / (z - y))
map = fun(x,y,z,w,v) ? lerp(unlerp(x,y,z),w,v)

mix = lerp
unmix = unlerp
remix = map



/* todo: make these intrinsic */

// note:
// yes, I could have used .loadexpr to make these
// automatically...

// TODO: instead of looking up by name,
// we can look up directly by index using
// new language features!
vec3__add = fun(that) ? vec3(this.x+that.x,this.y+that.y,this.z+that.z)
vec3__sub = fun(that) ? vec3(this.x-that.x,this.y-that.y,this.z-that.z)
vec3__mul = fun(that) ? vec3(this.x*that.x,this.y*that.y,this.z*that.z)
vec3__div = fun(that) ? vec3(this.x/that.x,this.y/that.y,this.z/that.z)
vec3__add1 = fun(that) ? vec3(this.x+that,this.y+that,this.z+that)
vec3__sub1 = fun(that) ? vec3(this.x-that,this.y-that,this.z-that)
vec3__mul1 = fun(that) ? vec3(this.x*that,this.y*that,this.z*that)
vec3__div1 = fun(that) ? {
	if that == 0 ? --> this:clone()
	--> vec3(this.x/that,this.y/that,this.z/that)
}


Vector3 = {
	__new = fun(x,y,z) ? {
		this.x = x
		this.y = y
		this.z = z
	}

	set = fun(x,y,z) ? {
		x ?= 0
		y ?= 0
		z ?= 0
		this.x = x
		this.y = y
		this.z = z
	}

	clone = fun() ? vec3(this.x,this.y,this.z),
	x = fun(x) ? vec3(x,this.y,this.z),
	y = fun(y) ? vec3(this.x,y,this.z),
	z = fun(z) ? vec3(this.x,this.y,z),

	abs = fun() ? vec3(abs(this.x),abs(this.y),abs(this.z))

	trim = fun(min,max) ? {
		--> vec3(trim(this.x,min.x,max.x),
					  trim(this.y,min.y,max.y),
					  trim(this.z,min.z,max.z))
	}

	min = fun(min) ? {
		--> vec3(min(this.x,min.x),
					  min(this.y,min.y),
					  min(this.z,min.z))
	}

	max = fun(max) ? {
		--> vec3(max(this.x,max.x),
					  max(this.y,max.y),
					  max(this.z,max.z))
	}

	eq = fun(that) ? (this.x==that.x&&this.y==that.y&&this.z==this.z),

	__add 	= vec3__add, 	add = vec3__add,
	__sub 	= vec3__sub, 	sub = vec3__sub,
	__mul 	= vec3__mul, 	mul = vec3__mul,
	__div 	= vec3__div, 	div = vec3__div,
	__add1 	= vec3__add1, add1 = vec3__add1,
	__sub1 	= vec3__sub1, sub1 = vec3__sub1,
	__mul1 	= vec3__mul1, mul1 = vec3__mul1,
	__div1 	= vec3__div1, div1 = vec3__div1,

	lenSq = fun() ? (this.x*this.x+this.y*this.y+this.z*this.z)

	len = fun() ? sqrt(this:lenSq()),

	dot = fun(that) ? (this.x*that.x + this.y*that.y + this.z*that.z),

	angle = fun() ? atan2(this.y,this.x)

	angleInDegrees = fun() ? atan2(this.y,this.x)*TODEG,


	mix = fun(that,ratio) ? {
		--> vec3(lerp(ratio,this.x,that.x),
					  lerp(ratio,this.y,that.y),
					  lerp(ratio,this.z,that.z))
	},

	lerp = fun(that,ratio) ? {
		--> this:mix(that,ratio)
	},

	floor = fun() ? vec3(floor(this.x),floor(this.y),floor(this.z)),
	toi = fun() ? vec3(ntoi(this.x),ntoi(this.y),ntoi(this.z)),

	norm = fun() ? this:div1(this:len()),

	dir = fun() ? this:div1(this:len()),

	cross = fun(that) ? {
		--> vec3(	this.y*that.z - this.z*that.y,
						this.z*that.x - this.x*that.z,
						this.x*that.y - this.y*that.x )
	}

	perp = fun() ? (this:cross(this))

	//-1,0, 0,1
	perp2d = fun() ? {
		--> vec2(this.y,-this.x)
	}

	relativeOrientation2d = fun(that) ? {
		--> this.x * that.y - this.y * that.x
	}

	cross2d = fun(that) ? {
		--> this.x * that.y - this.y * that.x
	}

	orthogonal2dCCW = fun() ? {
		--> vec2(-this.y,this.x)
	}

	orthogonal2d = fun() ? {
		--> vec2(this.y,-this.x)
	}

	transform2d = fun(x,y) ? {
		--> vec2(this.x * x.x + this.y * x.y,
		           this.x * y.x + this.y * y.y)
	}

	rotateByVec2d = fun(v) ? {
		--> vec2(this.x * v.x - this.y * v.y,
		           this.x * v.y + this.y * v.x)
	}

	rotateByAngle2d = fun(angle) ? {
		sinAngle := sin(angle)
		cosAngle := cos(angle)
		--> vec2(this.x * cosAngle - this.y * sinAngle,
		           this.x * sinAngle + this.y * cosAngle)
	}
}

vec3 = fun(x,y,z) ? {
	--> new Vector3(x,y,z)
}

vec2 = fun(x,y) ? vec3(x,y,.0)

vec = fun(x) ? {
	/* todo: make this better */
	if x != nil ? {
		_x := x.x if _x == nil ? _x = 0.
		_y := x.y if _y == nil ? _y = 0.
		_z := x.z if _z == nil ? _z = 0.
		--> vec3(_x,_y,_z)
	}
	--> vec3(.0,.0,.0)
}


LEFT  = vec3(-1, 0, 0)
RIGHT = vec3( 1, 0, 0)
UP    = vec3( 0, 1, 0)
DOWN  = vec3( 0,-1, 0)

// min ?= -PI
// max ?= +PI
// ref ?=  UP
rnddir2 = fun (min,max,ref) ? {
	ang := atan2(ref.y,ref.x) + mix(min,max,rnd(0.,1000.)/1000.)
	--> vec3(cos(ang),sin(ang),0.)
}


--> true
