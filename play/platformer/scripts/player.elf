
Entity = {
	__new = fun(type,position,size) ? {
		this.type       	= type
		this.position   	= vec2(position.x,position.y)
		this.velocity   	= vec()
		this.size 		 	= size ?? vec2(8,15)
		this.body       	= new Rect(this.position.x,this.position.y,this.size.x,this.size.y)
		this.animator   	= new FrameSequencer()
		this.flip_x 	 	= false
		this.image_groups = get_image_assets(type)
		this.action  		= nil
		this.animation 	= nil
		this.anim_offset  = {x=-3,y=3}
		this:set_action("idle")
	}
	set_action = fun(action) ? {
		if action != this.action ? {
			this.action = action
			images ::= this.image_groups[action]
			if images != nil && images:tally() != 0 ? {
				this.animation = images
				this.animator.num_frames = images:tally()
				this.animator:set_period(1.0)
			}
		}
	}
	tick = fun(time) ? {
		this.animator:tick(time)
	}
	draw = fun() ? {
		img ::= this.animation:idx(this.animator:get_frame())
		WINDOW:set_src_image(img)
		WINDOW:draw_image(this.position.x+this.anim_offset.x,this.position.y,img.width,img.height,this.flip_x,0)
		// VIEW.draw_image(img, {
		// 	x = this.position.x + this.anim_offset.x,
		// 	y = this.position.y + this.anim_offset.y - this.anim_offset.y,
		// 	w = img.width,
		// 	h = img.height,
		// }, {x=0,y=0,w=img.width,h=img.height,rotation=PI*total_time*0.01}, nil, 1, this.flip_x)
		total_time += WINDOW.time
	}

}
total_time = 0
Player = Entity:merge {
	super = Entity
	__new = fun(position,size) ? {
		position ?= vec()
		// todo: this is temporary, because
		// doing a table call will actually
		// pass in the table as 'this' as supposed
		// to the the current 'this'...
		__new := this:super.__new
		__new("player",position,size)

		this.air_time   	= 0
		this.jumps			= 1
		this.dashing		= 0
		this.wall_sliding = false
		this.engage_wall_slide_cue = false
	}
	tick = fun(time) ? {
		tick := this:super.tick
		tick(time)

		input := vec2(
		, ((WINDOW.keys[KEY_MOVE_RIGHT] & KEY_DOWN) != 0) - ((WINDOW.keys[KEY_MOVE_LEFT] & KEY_DOWN) != 0)
		, ((WINDOW.keys[KEY_MOVE_UP]    & KEY_DOWN) != 0) - ((WINDOW.keys[KEY_MOVE_DOWN] & KEY_DOWN) != 0) ):norm()
		input *= vec2(2,0)


		this.air_time += 1

		if this.position.y < -1000 ? {
			player_dead()
		}

		decay_rate ::= 2
		this.velocity.x -= this.velocity.x * decay_rate * time

		if WINDOW.keys[KEY_DASH] & KEY_PRESSED ? {
			iff this.dashing ? {
				if this.flip_x ? {
					this.dashing = -60
				} else {
					this.dashing = 60
				}
			}
		}
		if this.dashing > 0 ? {
			this.dashing = max(0,this.dashing-1)
		} else if this.dashing < 0 ? {
			this.dashing = min(0,this.dashing+1)
		}

		if abs(this.dashing) > 50 ? {
			this.velocity.x = 8.0 * abs(this.dashing) / this.dashing
			if abs(this.dashing) == 51 ? {
				this.velocity.x *= 0.1
			}
			{
				velocity ::= vec2(this.dashing/abs(this.dashing),0) * random() * 3
				add_particle("particle",this.position + this.size * 0.5, velocity)
			}
		}
		// create particle burst when dashing starts and ends
		if abs(this.dashing) == 50 || abs(this.dashing) == 60 ? {
			for i = 0...20 ? {
				angle ::= random() * TAU
				velocity ::= vec2(cos(angle),sin(angle)) * random()
				add_particle("particle",this.position + this.size * 0.5, velocity)
			}
		}

		intended_move_x := sign_or_zero(input.x)

		jumped := false
		if WINDOW.keys[KEY_MOVE_UP] & KEY_DOWN ? {
			if this.wall_sliding ? {
				k := WINDOW.keys
				if (k[KEY_MOVE_UP] & KEY_PRESSED) == 0 ? {
					if k[KEY_MOVE_LEFT] & KEY_PRESSED ? {
						intended_move_x = -1
					} else if k[KEY_MOVE_RIGHT] & KEY_PRESSED ? {
						intended_move_x = 1
					} else {
						intended_move_x = 0
					}
				}
				facing_right := this.flip_x == 0
				facing_left := this.flip_x != 0
				wants_move_left := intended_move_x < 0
				if intended_move_x != 0 && facing_left == wants_move_left ? {
					this.velocity = vec2(2.5 * -intended_move_x,3.5);
					this.wall_sliding = false
					this.engage_wall_slide_cue = true
					jumped = true
				} else if facing_left && intended_move_x > 0 ? {
					this.velocity.x = 3.5
					this.velocity.y = 2.5
					this.air_time 	 = 5
					this.jumps 		 = max(0, this.jumps - 1)
					jumped = true
					this.wall_sliding = false
					this.engage_wall_slide_cue = true
				} else if facing_right && intended_move_x < 0 ? {
					this.velocity.x = -3.5
					this.velocity.y =  2.5
					this.air_time 	 =  5
					this.jumps 		 = max(0, this.jumps - 1)
					jumped = true
					this.wall_sliding = false
					this.engage_wall_slide_cue = true
				}
			} else if this.jumps > 0 ? {
				if WINDOW.keys[KEY_MOVE_UP] & KEY_PRESSED ? {
					this.velocity 	= vec2(0,3)
					this.jumps 	  -= 1
					this.air_time 	= 5
					jumped = true
					this.engage_wall_slide_cue = false
				}
			}
		}
		if jumped ? {
			play_audio_asset("jump")
		}
		if this.wall_sliding ? {
			input *= vec2(0,0)
		}
		this.velocity += vec2(0,-6) * time
		move ::= input + this.velocity

		body ::= this.body
		collided ::= this.body:move_and_collide(move,fun() ? {
			--> get_overlapping_rects(body)
		})
		if collided.top || collided.bottom ? {
			this.velocity.y = 0
			this.velocity.x = 0
		}
		if collided.left || collided.right ? {
			this.velocity.x = 0
		}

		going_down := this.velocity.y < 0.05 || this.engage_wall_slide_cue
		wall_slide_right := intended_move_x > 0 && collided.right
		wall_slide_left := intended_move_x < 0 && collided.left
		wall_slide := wall_slide_left || wall_slide_right
		if going_down && wall_slide ? {
			this.engage_wall_slide_cue = false
			this.wall_sliding = true
			if wall_slide_left ? {
				this.flip_x = true
			} else {
				this.flip_x = false
			}
			// if this.air_time > 4 ? {
				// this.velocity.y = min(this.velocity.y,0.8)
			// }
		} else if this.wall_sliding ? {
			if this.flip_x == true ? {
				dummy := new Rect(this.body.x,this.body.y,this.body.w,this.body.h)
				collided ::= dummy:move_and_collide(vec2(-1,0),fun() ? {
					--> get_overlapping_rects(dummy)
				})
				iff collided.left ? {
					this.wall_sliding = false
				}
			} else {
				if this.flip_x == false ? {
					dummy := new Rect(this.body.x,this.body.y,this.body.w,this.body.h)
					collided ::= dummy:move_and_collide(vec2(1,0),fun() ? {
						--> get_overlapping_rects(dummy)
					})
					iff collided.right ? {
						this.wall_sliding = false
					}
				}
			}
		}
		if this.wall_sliding ? {
			iff WINDOW.keys[KEY_MOVE_DOWN] & KEY_DOWN ? {
				this.velocity.y -= this.velocity.y * 0.2
			}
		}
		if collided.bottom ? {
			this.air_time 		= 0
			this.jumps 	  		= 1
			this.wall_sliding = false
		}
		this.position.x = body.x
		this.position.y = body.y
		VIEW.set_camera_pos(this.position.x,this.position.y)

		if this.wall_sliding ? {
			this:set_action("wall_slide")
		} else {
			if this.air_time > 4 ? {
				this:set_action("jump")
			} else if move.x != 0 ? {
				this:set_action("run")
			} else {
				this:set_action("idle")
			}
			if move.x > 0 ? this.flip_x = false;
			else if move.x < 0 ? this.flip_x = true;
		}
	}
	draw = fun() ? {
		draw := this:super.draw
		if abs(this.dashing) <= 50 ? {
			draw()
		}
	}
}

