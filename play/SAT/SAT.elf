//
// TODO
//
load "vec.elf"

INFINITY = 1000000000

ranges_not_overlap = fun(a, b) ? {
	--> a.min >= b.max || b.min >= a.max
}

get_projected_point = fun(line, point) ? {
	axis := line.b - line.a
	mast := point - line.a
	--> line.a + axis * trim(mast:dot(axis) / axis:lenSq(),0,1)
}

Shape2D = elf.merge_tables(Vector3, {
	POLYGON    = 0
	RECTANGLE  = 1
	CIRCLE     = 2
	VERTEX_COLORS = {.CYAN,.MAGENTA,.PURPLE,.YELLOW}

	__new = fun(kind) ? {
		this.kind = kind
		this.transform ?= {
			rotation = 0,
			translation = vec()
		}
	}

	newRectangle = fun(x,y,w,h) ? {
		me := new Shape2D(Shape2D.RECTANGLE)
		me.x = x
		me.y = y
		me.w = w
		me.h = h

		me:add_vertex(vec2(x,y))
		me:add_vertex(vec2(x+w,y))
		me:add_vertex(vec2(x+w,y+h))
		me:add_vertex(vec2(x,y+h))
		--> me
	}


	newTriangle = fun(x,y,w,h) ? {
		me := new Shape2D(Shape2D.TRIANGLE)
		me.x = x
		me.y = y
		me.w = w
		me.h = h

		me:add_vertex(vec2(x,y))
		me:add_vertex(vec2(x+w,y))
		me:add_vertex(vec2(x+w,y+h))
		--> me
	}

	get_vertex_color = fun(idx) ? {
		--> Shape2D.VERTEX_COLORS:idx(idx) // [idx]
	}

	add_vertex = fun(vertex) ? {
		vertex = this:apply_transform_to_vertex(vertex)
		this.vertices ?= {}
		this.vertices:add(vertex)
	}
	restore = fun() ? {
		this.transform.rotation = 0
		this.transform.translation = vec()
	}
	set_rotation = fun(rotation) ? {
		this.transform.rotation = rotation
		this:clear_vertex_cache()
	}
	rotate = fun(rotation) ? {
		this.transform.rotation += rotation
		this:clear_vertex_cache()
	}
	translate = fun(translation) ? {
		this.transform.translation += translation
		this:clear_vertex_cache()
	}
	recompute_center = fun() ? {
		center := vec()
		vertices := this:get_vertices()
		for i = 0...vertices:tally() ? {
			center += vertices:idx(i)
		}
		center /= vertices:tally()
		this.center_ = center
		this.center = center
		--> center
	}
	get_center = fun() ? {
		center := this.center_
		center ?= this:recompute_center()
		--> center
	}
	clear_vertex_cache = fun() ? {
		this.normals_  = nil
		this.vertices_ = nil
		this.center_   = nil
	}
	apply_transform_to_vertex = fun(vertex) ? {
		vertex = vertex:rotateByAngle2d(this.transform.rotation)
		vertex += this.transform.translation
		--> vertex
	}
	recompute_vertices = fun() ? {
		vertices := this.vertices
		vertices_ := {}
		for i = 0...vertices:tally() ? {
			v := this:apply_transform_to_vertex(vertices:idx(i))
			vertices_:add(v)
		}
		this.vertices_ = vertices_
		--> vertices_
	}

	recompute_normals = fun() ? {
		normals := {}
		/* todo: */
		vertices := this:get_vertices()
		idx := vertices:idx
		for i = 0...vertices:tally() ? {
			a := vertices:idx(i+0)
			b := vertices:idx(i+1)
			normals:add((b - a):dir():orthogonal2d())
		}
		this.normals_ = normals
		--> normals
	}

	get_vertices = fun(fn) ? {
		vertices := this.vertices_
		vertices ?= this:recompute_vertices()
		--> vertices
	}

	get_normals = fun() ? {
		normals := this.normals_
		normals ?= this:recompute_normals()
		--> normals
	}

	get_collision_info = fun(that) ? {
		this_info := this:get_my_collision_info(that)
		if this_info == nil ? --> nil
		that_info := that:get_my_collision_info(this)
		if that_info == nil ? --> nil
		if this_info.distance < that_info.distance ? {
			--> this_info
		}
		// that_info.normal *= -1
		--> that_info
	}
	get_furthest_vertex_along_direction = fun(direction) ? {
		best_vertex := vec()
		best_projection := -INFINITY
		vertices := this:get_vertices()
		for i = 0...vertices:tally() ? {
			v := vertices:idx(i)
			p := v:dot(direction)
			if p > best_projection ? {
				best_vertex = v
				best_projection = p
			}
		}
		--> best_vertex
	}
	project_vertices = fun(line) ? {
		list := {}
		vertices := this:get_vertices()
		for j = 0...vertices:tally() ? {
			vertex := vertices:idx(j)
			list:add(get_projected_point(line,vertex))
		}
		--> list
	}
	get_projection_range = fun(normal) ? {
		range_min := INFINITY
		range_max := -INFINITY
		if this.type == Shape2D.CIRCLE ? {
			range_min = this-this.radius
			range_max = this+this.radius
		} else {
			vertices := this:get_vertices()
			for it = vertices[..] ? {
				p := it:dot(normal)
				range_min = min(range_min,p)
				range_max = max(range_max,p)
			}
		}
		--> {min=range_min,max=range_max}
	}
	get_my_collision_info = fun(that) ? {
		normals := this:get_normals()
		distance := INFINITY
		normal := nil
		for i = 0...normals:tally() ? {
			n := normals:idx(i)
			this_range := this:get_projection_range(n)
			that_range := that:get_projection_range(n)
			if ranges_not_overlap(this_range,that_range) ? {
				--> nil
			}

			it_distance := min(
				that_range.max - this_range.min,
				this_range.max - that_range.min )

			if it_distance < distance ? {
				distance = it_distance
				normal = n
			}
		}
		--> { shape = this, normal = normal, distance = distance }
	}

	applySmoothing = fun(strength) ? {
		vertices := this:get_vertices()

		for n = 0...strength ? {
			buffer := {}
			for i = 0...vertices:length() ? {
				p0 := vertices:idx(i+0)
				p1 := vertices:idx(i+1)
				buffer:add(vec2(.75*p0.x + .25*p1.x, .75*p0.y + .25*p1.y))
				buffer:add(vec2(.25*p0.x + .75*p1.x, .25*p0.y + .75*p1.y))
			}
			vertices = buffer
		}

		this:clear_vertex_cache()
		this.vertices = vertices

		--> vertices:length()
	}

	draw = fun(config) ? {
		line_thickness := nil
		color := nil
		if config != nil ? {
			line_thickness = config.line_thickness
			color = config.color
		}
		line_thickness ?= 2
 		color ?= .WHITE
		vertices := this:get_vertices()

		.ResetSamplingTexture()

		if this.type == Shape2D.CIRCLE ? {

		} else {
			normal_colors := {.RED,.BLUE,.GREEN,.ORANGE}
			vertex_colors := {.CYAN,.MAGENTA,.PURPLE,.YELLOW}
			normals := this:get_normals()
			for i = 0...vertices:tally() ? {
				a := vertices:idx(i+0)
				b := vertices:idx(i+1)
				// d := b - a
				// n := normals:idx(i)
				// m := a + d * .45
				// .DrawLine(m,m+n*10,line_thickness,normal_colors[i])
				.DrawLine(a,b,line_thickness,color)
			}
			.DrawCircle(this:get_center(),4,.WHITE)
		}
		for i = 0...vertices:tally() ? {
			.DrawCircle(vertices:idx(i),4,Shape2D.get_vertex_color(i))
		}
	}
})




triangleArea = fun(x1, y1, x2, y2, x3, y3) ? {
	--> abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0)
}

/* todo: replace with better formula using the
cross product! */
isPointInTriangle = fun (px, py, v1, v2, v3) ? {
	x1 := v1.x
	y1 := v1.y
	x2 := v2.x
	y2 := v2.y
	x3 := v3.x
	y3 := v3.y
	A = triangleArea(x1, y1, x2, y2, x3, y3)
	B = triangleArea(px, py, x2, y2, x3, y3)
	C = triangleArea(x1, y1, px, py, x3, y3)
	D = triangleArea(x1, y1, x2, y2, px, py)
	/* not sure if what I'm doing here is redundant */
	--> abs(A - (B + C + D)) < 0.00001
}

triangulate = fun(vertices) ? {
	vertices = vertices:xclone()
	triangles := {}
	if vertices:length() < 3 ? {
		--> triangles
	}
	while vertices:length() > 3 ? {
		for i = 0...vertices:length() ? {
			t0 := vertices:idx(i-1)
			t1 := vertices:idx(i)
			t2 := vertices:idx(i+1)
			is_ear := true
			for j = 0...vertices:length() ? {
				pt := vertices:idx(j)
				if pt == t0 || pt == t1 || pt == t2 ? {
					continue
				}

				if isPointInTriangle(pt.x,pt.y,t0,t1,t2) ? {
					is_ear = false
					break
				}
			}
			if is_ear ? {
				triangles:add({ t0, t1, t2 })
				vertices:xrem(i)
				break
			}
		}
	}
	if vertices:length() > 2 ? {
		triangles:add({vertices:idx(0),vertices:idx(1),vertices:idx(2)})
	}
	--> triangles
}


// https://iquilezles.org/articles/simpleik/
// r1 and r2 are the radii of the circles
// or lengths of the segments...
// Function works in local space...
// There are two solutions, use root to
// pick either the negative or positive
// solution...
solveCircleIntersection = fun(p,r1,r2,root,error) ? {
	r1Sq := r1*r1
	r2Sq := r2*r2
	q := p*(0.5+0.5*(r1Sq-r2Sq)/p:lenSq());

	s := r1Sq/q:dot(q)-1.0;
	if(s < 0.0) ? --> error
	--> vec2(-q.y,q.x)*root*sqrt(s) + q
}


