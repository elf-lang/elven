PI  = 3.14159
TAU = 6.28318
E   = 2.71828

max := fun(a,b) ? { if a > b ? --> a else --> b }
min := fun(a,b) ? { if a < b ? --> a else --> b }

UPSCALE  	::= 1
WIND_W   	::= 512
WIND_H   	::= 512
UNIT 			::= 8
CENTER_X 	::= WIND_W * 0.5
CENTER_Y 	::= WIND_H * 0.5
CELL 			::= UNIT

_rgb = fun(r,g,b,a) ? ({r=r,g=g,b=b,a=a??255})

InitWindow("Graph!",WIND_W,WIND_H,UPSCALE)

DOWN 		= 1
PRESSED  = 2
RELEASED = 4

initial_offset = { x = CENTER_X, y = CENTER_Y }
offset = { x = CENTER_X, y = CENTER_Y }
zoom = 1

zoom_in_at_mouse ::= fun(by) ? {
	by ?= 0.01
	new_scale ::= zoom + zoom * by
	if new_scale <= 0 ? {
		ret
	}
	mouse_x ::= GetMouseX() * WIND_W
	mouse_y ::= GetMouseY() * WIND_H
	a ::= zoom / new_scale
	if a != 0 ? {
		offset.x = mouse_x - (mouse_x - offset.x) / a
		offset.y = mouse_y - (mouse_y - offset.y) / a
		zoom = new_scale
	}
}

offset_minus_mouse := {x=0,y=0}


force_radius := 8.0
	force_dropoff := 16.0
	sources := {
		{
			c = _rgb(0,0,255)
			f = fun(x) ? {
				--> x
			},
		},
		{
			c = _rgb(255,255,0)
			f = fun(x) ? {
				if x < force_radius ? {
					--> 2
				} else {
					--> 1 - min((x - force_radius) / force_dropoff, 1.0)
				}
			},
		},
		{
			f = fun(x) ? {
				if x < 2 ? {
					--> 4
				} else {
					--> 4+1 - x / 2
				}
			},
			c = _rgb(255,0,255)
		},
	}
	old := {
		{
			f = fun(x) ? (x),
			c = _rgb(255,255,0)
		},
		{
			f = fun(x) ? (x * x * x),
			c = _rgb(0,255,255)
		},
		{
			f = fun(x) ? sin(x)
			c = _rgb(64,64,255)
		},
		{
			f = fun(x) ? 1.0 / (0.1 + x)
			c = _rgb(64,64,255)
		},
		{
			f = fun(x) ? pow(MATH.E,x)
			c = _rgb(64,64,255)
		}
	}


while PollWindow() ? {
	Clear(32, 32, 32, 255)

	if Button('Z') & 1 ? { zoom_in_at_mouse(0.01) }
	if Button('X') & 1 ? { zoom_in_at_mouse(-0.01) }
	if Button('W') & 1 ? { offset.y -= 1 }
	if Button('S') & 1 ? { offset.y += 1 }
	if Button('A') & 1 ? { offset.x -= 1 }
	if Button('D') & 1 ? { offset.x += 1 }
	if Button('R') & 1 ? {
		offset = INITIAL_OFFSET:clone()
		zoom   = 1.0
	}

	mouse_x ::= GetMouseX() * WIND_W
	mouse_y ::= GetMouseY() * WIND_H

	if MouseButton(0) & 2 ? {
		dragging = true
		offset_minus_mouse.x = offset.x - mouse_x
		offset_minus_mouse.y = offset.y - mouse_y
	}
	if MouseButton(0) & 1 ? {
		if dragging ? {
			offset.x = offset_minus_mouse.x + mouse_x
			offset.y = offset_minus_mouse.y + mouse_y
		}
	}

	cell_size   ::= CELL * zoom
	grid_size_x ::= WIND_W / cell_size + 1
	grid_size_y ::= WIND_H / cell_size + 1

	SetColor(255,255,255,255*0.25)
	for y = 0...grid_size_y ? {
		y0 := offset.y % cell_size + y * cell_size
		DrawLine(0, y0, WIND_W, y0)
	}
	for x = 0...grid_size_x ? {
		x0 := offset.x % cell_size + x * cell_size
		DrawLine(x0, 0, x0, WIND_H)
	}
	SetColor(255,0,0,255*0.80)
	DrawLine(offset.x, 0, offset.x, WIND_H)
	SetColor(0,255,0,255*0.80)
	DrawLine(0, offset.y, WIND_W, offset.y)


	// todo: instead of sampling this way,
	// we should sample starting at the
	// origin moving away in both directions,
	// that way we can stop sampling once we
	// go outside the screen
	for src = sources[...] ? {
		f ::= src.f
		c ::= src.c
		SetColor(c.r,c.g,c.b,c.a)
		// sample in screen space, number of samples
		// remains the same regardless of the scale
		for p = 0...WIND_W ? {
			xv ::= p - offset.x
			x0 ::= (xv + 0) / zoom
			x1 ::= (xv + 1) / zoom
			y0 ::= f(x0 / UNIT) * UNIT
			y1 ::= f(x1 / UNIT) * UNIT
			ddx := 0
			if (y1 - y0) != 0 ? {
				ddx = (x1 - x0) / (y1 - y0)
			}
			sy0 := offset.y - y0 * zoom
			sy1 := offset.y - y1 * zoom
			// window space clipping
			// todo: clipping should depend on the slope,
			// like if we're going up then x0 will be on
			// the bottom... y1 on top and vice versa.
			// also when we get really steep functions
			// the lines would be huge...
			if sy0 < 0 || sy0 > WIND_H ? {
				continue
			}
			if sy1 < 0 ? {
				sy1 = 0
			}

			// todo: figure out how to make this more efficient...
			DrawLine((p+0),sy0,(p+1),sy1)
		}
	}
}