point_in_rect = fun(px,py,x,y,w,h) ? {
	--> ((px >= x) && (px < x + w))
	&&  ((py >= y) && (py < y + h))
}

Rect = {
	__new = fun(x,y,w,h,c) ? {
		this.x=x
		this.y=y
		this.w=w
		this.h=h
		this.c=c ?? WHITE
	}
	test = fun() ? {
		if (new Rect(0,0,1,1)):overlaps(new Rect(0,1,1,1)) ? {
			elf.pf("Rect Is Wrong!")
		}
		if (new Rect(0,0,1,1)):overlaps(new Rect(1,0,1,1)) ? {
			elf.pf("Rect Is Wrong!")
		}
	}
	contains = fun(point) ? {
		--> this:overlaps(new Rect(point.x,point.y,1,1))
	}


	overlaps = fun(that) ? {
		--> this.x + this.w > that.x
		&&  this.y + this.h > that.y
		&&  that.x + that.w > this.x
		&&  that.y + that.h > this.y
	}
	overlaps4 = fun(that_x,that_y,that_w,that_h) ? {
		--> this.x + this.w > that_x
		&&  this.y + this.h > that_y
		&&  that_x + that_w > this.x
		&&  that_y + that_h > this.y
	}

	move_and_collide = fun(move,get_rects) ? {
		info ::= {
			collided = false,
			left 		= false,
			right 	= false,
			top 		= false,
			bottom 	= false,
			// dist_x 	= nil,
			// dist_y 	= nil,
		}

		for i = 0,1 ? {
			if i == 0 ? this.x += move.x;
			else 			this.y += move.y;
			check_rects ::= get_rects(this)
			for that = check_rects[...] ? {
				info.collided = true
				if i == 0 ? {
					if move.x > 0 ? {
						info.right = true
						this.x = that.x - this.w;
					} else {
						info.left  = true
						this.x = that.x + that.w;
					}
				} else {
					if move.y > 0 ? {
						info.top = true
						this.y = that.y - this.h;
					} else {
						info.bottom = true
						this.y = that.y + that.h;
					}
				}
			}
		}
		--> info
	}
}