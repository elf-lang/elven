// todo: this is temporay, we should
// be able to pass in arguments later...


// {
// 	EDITOR_PATH=".."
// 	prev ::= elf.get_work_dir()
// 	elf.change_work_dir("editor")
// 	load "main.elf"
// 	elf.change_work_dir(prev)
// }
// #eof


UPSCALE  	::= 4
WIND_W   	::= 128 // 320
WIND_H   	::= 128 // 240
ASPECT_R 	::= WIND_W / iton(WIND_H)
CENTER_X 	::= WIND_W / 2
CENTER_Y 	::= WIND_H / 2
TILE_SIZE 	::= 8

load "math.elf"

elf.audio.init()
VIEW=new elf.gfx.Window("Collision!",WIND_W,WIND_H,UPSCALE)

// todo: if you set this to a local,
// the editor's camera is is the same
// as this...
GAME_CAMERA = new Camera(vec2(0,VIEW.res_y),vec2(1,-1))

PRESSED  = elf.gfx.Window.PRESSED
DOWN 		= elf.gfx.Window.DOWN
RELEASED = elf.gfx.Window.RELEASED

// #test "hard binding error"
// warnings := #getwarnings()
// #assert warnings[0] == 0
MAX_NJUMPS=1

tiles_image  ::= elf.gfx.load_image("tiles.png")
tilemap={}

load "entities.elf"
bubbles := {}
wind_particles = {}
for i = 0...8 ? {
	bubbles:add({
		random=random(),
		x=random()*9999,
		y=random()*9999,
	})
	wind_particles:add({
		random=random(),
		x=random()*9999,
		y=random()*9999,
	})
}


tile_type_to_coord:={
	0=vec2(8,1),

	1=vec2(10+0,0),
	2=vec2(10+1,0),
	3=vec2(10+2,0),

	4=vec2(10+0,1),
	5=vec2(10+1,1),
	6=vec2(10+2,1),

	7=vec2(10+0,2),
	8=vec2(10+1,2),
	9=vec2(10+2,2),
}
TYPE_TO_NAME={"floor"}
Tile={
	_tag="tile"
	__new=fun(x,y)?{
		this.type=0
		this.spr=new Sprite(this:_tag,x,y,8,8)
	}
	draw=fun()?{
		// this.spr:draw()
		spr ::= this.spr
		x := spr.x
		y := spr.y
		c := tile_type_to_coord[this.type]
		VIEW:set_src_rect(c.x*8,c.y*8,8,8)
		VIEW:draw_image(x,y,8,8,spr.xflip,0)
	}
	tick=fun()?{
		this.spr:tick()
	}
}

metathings={
	"key"=Key,
	"player"=Player,
	"tile"=Tile
}

///////////////////////////
// level loading / editing

static_things={}

coords_to_tile ::= fun(x,y) ? {
	tile_x ::= ntoi(floor(x))
	tile_y ::= ntoi(floor(y))
	key ::= "" + tile_x + ";" + tile_y
	--> {key=key,tile_x=tile_x,tile_y=tile_y}
}

place_thing ::= fun(x,y,thing) ? {
	info ::= coords_to_tile(x,y)
	if info ? {
		tile_x ::= info.tile_x
		tile_y ::= info.tile_y
		key ::= info.key
		thing ?= new Tile(0,0)
		if thing.spr != nil ? {
			thing.spr.x = tile_x*TILE_SIZE
			thing.spr.y = tile_y*TILE_SIZE
		}else{
			thing.x = tile_x*TILE_SIZE
			thing.y = tile_y*TILE_SIZE
		}
		static_things[key] = thing
	}
}

player_spawn:=vec2(VIEW.res_x*0.5,VIEW.res_y*0.5)
load_level=fun()?{
	file := elf.open_file("editor_save.elf","rb")
	defer elf.close_file(file)
	data := elf.const_expr(elf.read_file(file))
	if data ? {
		tileid_to_def ::= {}
		for group = data.groups[...] ? {
			for tiledef = group.tiles[...] ? {
				tileid_to_def[tiledef.id]=tiledef
				tiledef.group=group
			}
		}
		for tile = data.tiles[...]?{
			id::=tile:idx(0)
			def::=tileid_to_def[id]
			tile_x::=tile:idx(1)
			tile_y::=tile:idx(2)
			if def.group.name=="spawners"?{
				if def.name=="player"?{
					player_spawn.x=tile_x*TILE_SIZE
					player_spawn.y=tile_y*TILE_SIZE
				} else if def.name=="key"?{
					skull:=new Skull(tile_x*TILE_SIZE,tile_y*TILE_SIZE)
					skull.props={}
					skull.props.tick=fun(time)?(skull:tick(time))
					skull.props.draw=fun()?(skull:draw())
					ecs_add(skull)
					// place_thing(tile_x,tile_y,)
				}
			}else if def.group.name=="dirt"?{
				key::=coords_to_tile(tile_x,tile_y)
				tilemap[key]={x=tile_x,y=tile_y,tiledef=def}
				place_thing(tile_x,tile_y)
			}
		}
	}
}


load_level()

get_tile:=fun(x,y)?{
	x=ntoi(x)
	y=ntoi(y)
	info ::= coords_to_tile(x*TILE_SIZE,y*TILE_SIZE)
	if info ? {
		tile_x ::= info.tile_x
		tile_y ::= info.tile_y
		key ::= info.key
		tile := static_things[key]
		if tile && tile:_tag=="tile" ? {
			--> tile
		}
	}
	--> nil
}


spikes={}
sprites={}
platforms={}
total_time=0
freeze=0
shake=0
spawn_player=fun()?{
	player?=new Player(0,0)
	player.spr.x=player_spawn.x
	player.spr.y=player_spawn.y
	player.dead=false
	// player.props={tick=fun(time)?{
	// 	player:tick(time)
	// },draw=fun()?{
	// 	player:draw()
	// }}
	// ecs_add(player)
	player.spr.v=vec2()
	player.spr.m=vec2()
}
spawn_player()
sprites:add(player)


// platforms:add(new Sprite("platform",32,32,32,8))
// platforms:add(new Sprite("platform",64,32,32,8))

cur_spr_index := 0

view ::= VIEW
while view:poll() ? {

	time ::= view.time
	total_time += time

	// view:set_color(121,37,45,255)
	view:set_color(235,150,158,255)
	view:draw_rect(0,0,view.res_x,view.res_y)

	view:set_color(179,70,80,255)
	for bub = bubbles[...] ? {
		bub.x += 0.01 + sin(total_time * 0.1 * PI + bub.random) * 0.1
		bub.y -= 0.02
		rad := 4 + bub.random*8

		draw_x := bub.x % (view.res_x + rad*2) - rad*2
		draw_y := bub.y % (view.res_y + rad*2) - rad*2

		view:draw_circle(draw_x,draw_y,rad)
	}

	view:set_color(235,204,207,255)
	for par = wind_particles[...] ? {
		par.x += 0.01 + sin(total_time * 0.1 * PI + par.random) * 0.1
		par.y += 0.01

		rad := 1
		draw_x := par.x % (view.res_x + rad*2) - rad*2
		draw_y := par.y % (view.res_y + rad*2) - rad*2

		view:draw_rect(draw_x,draw_y,1,1)
	}

	view:set_color(255,255,255,255)

	camera ::= GAME_CAMERA
	camera.offset.x=-ntoi(floor(player.spr.x/128.0))*128
	camera.offset.y=(1+ntoi(floor(player.spr.y/128.0)))*128
	view:set_offset(camera.offset.x,camera.offset.y)
	view:set_scale(camera.scale.x,camera.scale.y)
	view:set_src_image(tiles_image)

	if player.dead?{
		if freeze==0?{
			freeze=60
		}else if freeze==1?{
			spawn_player()
		}
	}
	if freeze>0?{
		freeze-=1
	}

	if freeze<=0?{
		tick_ecs(time)
		for spr = sprites[...] ? {
			if spr ? {
				spr:tick(time)
			}
		}
	}

	for spr = sprites[...], static_things[...], platforms[...] ? {
		if spr != nil ? {
			spr:draw()
		}
	}

	draw_ecs()

	view:set_offset(0,0)
	view:set_scale(1,1)
}


#eof

for plat = platforms[...] ? {
	move := vec2()
	if plat == platforms:idx(0) ? {
		move.y = sin(total_time*PI*0.5)*2
	} else {
		move.x = sin(total_time*PI*0.5)*2
	}
	plat.x+=move.x
	plat.y+=move.y
	for that = sprites[...] ? {
		iff plat:overlaps(that) ? {
			continue
		}
		plat.colliding = true
		that.colliding = true
		if plat.y < that.y ? {
			if that.v.y < 0 ? {
				that.y = plat.y + plat.h;
				that.v.y = 0
				that.v.x = 0
				that.m.x += move.x
					// that.x += move.x
				jump_buffer=1
			}
		}
	}
}
