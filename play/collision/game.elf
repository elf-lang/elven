// based off of celeste
MAX_NJUMPS=1
MAX_FALL=2
MAX_FALL_WHEN_WALLSLIDING=0.40

GRAVITY=0.21
GRAVITY_POSITIVE_THRESHOLD=0.15
GRAVITY_MULTIPLIER_WHEN_PAST_POSITIVE_THRESHOLD=0.50

ACCELERATION_WHEN_ON_GROUND=0.5
DECCELERATION=0.13

get_input=fun()?{
	xy := vec2(
	, (VIEW.keys['D'] & DOWN) - (VIEW.keys['A'] & DOWN)
	, (VIEW.keys['W'] & DOWN) - (VIEW.keys['S'] & DOWN))
	xy.jump = VIEW.keys['W'] & PRESSED
	--> xy
}

spr=fun(tile,x,y,fx,fy)?{
	src_x::=ntoi(tile)%16*8
	src_y::=ntoi(tile)/16*8
	SetRegion(src_x,src_y,8,8)
	DrawRectangle(x,y,8,8,fx??0,fy??0)
}

game={}

init_game=fun(assets){
	game.assets=assets
	game.load_scene()
}

tick_game=fun(time){
	if freeze>0?{
		freeze-=1
		--> ;
	}
	view::=VIEW
	camera::=camera
	offset::=camera.offset

	offset.x=-ntoi(floor(player.x/view.res_x))*view.res_x
	offset.y=(1+ntoi(floor(player.y/view.res_y)))*view.res_y

	// screenshake
	if shake>0?{
		offset.x+=(random()*2-1)*2
		offset.y+=(random()*2-1)*2
		shake-=1
	}

	// restart
	if will_restart && restart_delay>0 ? {
		restart_delay-=1
		if restart_delay<=0?{
			will_restart=false
			game.load_scene()
		}
	}

	// update
	tick_objs(time)
}
draw_game=fun(){
	view::=VIEW
	camera::=camera
	offset::=camera.offset
	tiles_image::=game.assets.images.tiles

	// draw screen effects
	SetOffset(0,0)
	SetScale(1,1)


	// SetColor(121,37,45,255)
	SetColor(235,150,158,255)
	DrawRectangle(0,0,view.res_x,view.res_y)

	SetColor(179,70,80,255)
	for bub = bubbles[...] ? {
		bub.x += 0.01 + sin(total_time * 0.1 * PI + bub.random) * 0.1
		bub.y -= 0.02
		rad := 4 + bub.random*8

		draw_x := bub.x % (view.res_x + rad*2) - rad*2
		draw_y := bub.y % (view.res_y + rad*2) - rad*2

		DrawCircle(draw_x,draw_y,rad, 2)
	}

	SetColor(235,204,207,255)
	for par = wind_particles[...] ? {
		par.x += 0.01 + sin(total_time * 0.1 * PI + par.random) * 0.1
		par.y += 0.01

		rad := 1
		draw_x := par.x % (view.res_x + rad*2) - rad*2
		draw_y := par.y % (view.res_y + rad*2) - rad*2

		DrawRectangle(draw_x,draw_y,1,1)
	}

	SetColor(255,255,255,255)

	// draw world things
	SetOffset(offset.x,offset.y)
	SetScale(camera.scale.x,camera.scale.y)

	D_SetTexture(tiles_image)
	SetColor(255,255,255,255)
	new_dead_particles := {}
	for par = dead_particles[...]?{
		if par.t > 0 ? {
			par.x += par.spd.x
			par.y += par.spd.y
			par.t -= 1
			size:=par.t/5.0
			DrawRectangle(par.x,par.y,size,size)
			new_dead_particles:add(par)
		}
	}
	dead_particles=new_dead_particles

	for tile = game.tilemap[...] ? {
		// tile.info ?= game.assets.get_tile_info(game.assets.tilesets.tiles,tile.id)
		info ::= tile.info
		id ::= ntoi(info.coords.x / 8 + info.coords.y / 8 * 16)
		spr(id,tile.x,tile.y)
	}

	// pos := VIEW.get_camera_pos()
	// size := VIEW.get_camera_size()
	// x0 := ntoi(floor((pos.x - size.x * 0.5) / tile_size))
	// y0 := ntoi(floor((pos.y - size.y * 0.5) / tile_size))
	// y1 := ntoi(ceil((pos.y + size.y * 0.5) / tile_size))
	// x1 := ntoi(ceil((pos.x + size.x * 0.5) / tile_size))

	// for ty = y0...y1 + 1 ? {
	// 	for tx = x0...x1 + 1 ? {
	// 		tile := get_tile(tx,ty)
	// 		if tile == nil ? {
	// 			continue
	// 		}
	// 		x := tx * tile_size
	// 		y := ty * tile_size
	// 		img ::= tile_assets[tile.type]:idx(tile.variant)
	// 		WINDOW:set_src_image(img)
	// 		WINDOW:draw_image(x,y)
	// 	}
	// }

	draw_objs()
}
restart_level=fun()?{
	will_restart=true
	restart_delay=15
}
kill_player=fun()?{
	deaths+=1
	shake=10
	spawn_death_particles(player)
	restart_level()
}
spawn_death_particles=fun(obj)?{
	dead_particles={}
	for dir=0...8?{
		angle::=PI*2/8*dir
		dead_particles:add({
			x=obj.x+4,
			y=obj.y+4,
			t=20,
			spd=vec2(sin(angle)*3,cos(angle)*3)
		})
	}
}
clean_level=fun()?{
	camera=new Camera(vec2(0,VIEW.res_y),vec2(1,-1))
	TILE_SIZE=8
	deaths=0
	total_time=0
	freeze=0
	shake=0
	will_restart=false
	restart_delay=false
	objects={}
	game.tilemap={}
	bubbles={}
	wind_particles={}
	dead_particles={}
	player=nil
}

game.update_scene=fun(id,info,x,y)?{
	pos ::= vec2(x,y) * TILE_SIZE
	if info.group.name=="spawners"?{
		if info.name=="player"?{
			player=spawn(Player,pos)
			player.dead=false
			player.spd=vec2()
		} else if info.name=="key"?{
			spawn(Key,pos)
		} else if info.name=="skull"?{
			spawn(Skull,pos)
		}
	}else if info.group.name=="dirt"?{
		key ::= "" + x + ";" + y
		game_tile ::= {id=id,x=pos.x,y=pos.y,info=info,w=8,h=8}
		game.tilemap[key] = game_tile
	}
}
game.load_scene=fun()?{
	clean_level()
	for i = 0...8 ? {
		bubbles:add({random=random(),x=random()*9999,y=random()*9999})
		wind_particles:add({random=random(),x=random()*9999,y=random()*9999})
	}

	data := game.assets.get_scene(0)
	if data ? {
		for tile = data.tiles[...]?{
			id ::= tile:idx(0)
			x ::= tile:idx(1)
			y ::= tile:idx(2)
			info ::= game.assets.get_tile_info(game.assets.tilesets.tiles,id)
			game.update_scene(id,info,x,y)
		}
	}
}

//
// objects
//
tick_objs=fun(time)?{
	//todo:!
	new_objs:={}
	for obj=objects[...]?{
		obj:tick(time)
		if obj.dead==true?{
		}else{
			new_objs:add(obj)
		}
	}
	objects=new_objs
}
draw_objs=fun()?{
	for obj=objects[...]?{
		if obj!=nil?{
			obj:draw()
		}
	}
}

spawn=fun(objtype,pos)?{
	obj ::= new object(objtype,pos.x,pos.y)
	objects:add(obj)
	--> obj
}

object={
	__new=fun(type,x,y,w,h,tile,solid) ? {
		this.type=type
		this.x=x
		this.y=y
		this.xrem=0
		this.yrem=0
		this.w=w??8
		this.h=h??8
		this.spd=vec2()
		this.tilespd=0
		this.tilenum=1
		this.tileoff=0
		this.tile=tile??0
		this.flip={x=false,y=false}

		this.color=WHITE
		this.solid=solid??true

		init ::= type.init
		if init?{
			init(time)
		}
	}
	tick=fun(time)?{
		tick ::= this.type.tick
		if tick?{
			tick(time)
		}
	}
	draw=fun()?{
		draw ::= this.type.draw
		if draw?{
			draw(time)
		}else{
			this.tileoff+=this.tilespd;
			offs ::= ntoi(this.tileoff)
			tile ::= this.tile+offs%this.tilenum
			y ::= this.y
			if this.tileoff>this.tilenum?{
				this.tileoff=0
			}
			if offs%3==0?{
				y+=1
			}
			spr(tile,this.x,y,this.flip.x,0)
		}
	}
	overlaps=fun(that,x_border,y_border)?{
		x_border ?= 0
		y_border ?= 0
		--> this.x + this.w > that.x - x_border
		&&  this.y + this.h > that.y - y_border
		&&  that.x + that.w > this.x - x_border
		&&  that.y + that.h > this.y - y_border
	}
	// todo: this doesn't return the wall normal for the
	// x axis
	get_wall_normal=fun(x_border,y_border)?{
		x_border ?= 0
		y_border ?= 0
		if this.y-y_border<=0 ?{
			--> vec2(0,1)
		}
		normal := vec2()
		for that = game.tilemap[...] ? {
			that.w?=8
			that.h?=8
			if this:overlaps(that,x_border,0) ? {
				normal.x = (this.x > that.x) * 2 - 1
				break
			}
		}
		for that = game.tilemap[...] ? {
			if this:overlaps(that,0,y_border) ? {
				normal.y = (this.y > that.y) * 2 - 1
				break
			}
		}
		--> normal
	}
	move=fun(move)?{
		for axis = 0,1 ? {
			if axis == 0 ? {
				this.xrem += move.x
				mov := floor(this.xrem)
				this.xrem -= mov
				this.x += mov
			} else {
				this.yrem += move.y
				mov := floor(this.yrem)
				this.yrem -= mov
				this.y += mov
			}

			tiles ::= {}
			for that = game.tilemap[...] ? {
				if this:overlaps(that) ? {
					if axis == 0 ? {
						if move.x > 0 ? {
							this.x = that.x - this.w;
						} else if move.x < 0 ? {
							this.x = that.x + that.w;
						}
					} else {
						if move.y > 0 ? {
							this.y = that.y - this.h;
						} else if move.y < 0 ? {
							this.y = that.y + that.h;
						}
					}
				}
			}

			// negative coordinates are not valid...
			if this.x < 0 ? this.x = 0;
			if this.y < 0 ? this.y = 0;

			// else if this.x + this.w > VIEW.res_x ? this.x = VIEW.res_x - this.w;
			// else if this.y + this.h > VIEW.res_y ? this.y = VIEW.res_y - this.h;
		}
	}
}

Player={
	_tag="player"
	init=fun()?{
		this.tile=3
		this.tilespd=0.15
		this.tilenum=3
		this.dasheffectframes=0
		this.dashframes=0
		this.dashacc=vec2()
		this.dashspd=vec2()
		this.remainingjumps=MAX_NJUMPS
		this.jumpbuffer=0
		this.jumpframes=0
	}
	tick=fun(time)?{
		dash ::= VIEW.keys[' '] & PRESSED
		input := get_input()


		walls ::= this:get_wall_normal(3,3)
		on_ground := walls.y>0


		if this.dasheffectframes>0?{
			this.dasheffectframes-=1
		}
		if this.dashframes > 0 ? {
			this.dashframes -= 1
			this.spd.x=appr(this.spd.x,this.dashspd.x,this.dashacc.x)
			this.spd.y=appr(this.spd.y,this.dashspd.y,this.dashacc.y)
		} else {
			maxrun 	:= 1
			accel 	:= 0.6
			deccel 	:= 0.15
			on_ice 	:= false

			if on_ground ? {
				if on_ice ? {
					accel=0.05
				}
			} else {
				accel=0.4
			}
			if abs(this.spd.x) > maxrun ? {
				this.spd.x=appr(this.spd.x,signz(this.spd.x)*maxrun,deccel)
			} else {
				this.spd.x=appr(this.spd.x,input.x*maxrun,accel)
			}
			if this.spd.x != 0 ? {
				this.flip.x = this.spd.x < 0
			}

			// gravity
			maxfall := MAX_FALL
			gravity := GRAVITY
			if this.spd.y >= GRAVITY_POSITIVE_THRESHOLD ? {
				gravity *= GRAVITY_MULTIPLIER_WHEN_PAST_POSITIVE_THRESHOLD
			}
			if input.x!=0 && walls.x!=0 ? {
				maxfall=MAX_FALL_WHEN_WALLSLIDING
			}

			iff on_ground ? {
				this.spd.y=appr(this.spd.y,-maxfall,gravity)
			}

			// jump
			if on_ground ? {
				this.jumpframes=6
				if this.remainingjumps<MAX_NJUMPS ? {
					this.remainingjumps=MAX_NJUMPS
				}
			} else {
				this.jumpframes-=1
			}
			if input.jump ? {
				this.jumpbuffer = 6
			} else if this.jumpbuffer > 0 ? {
				this.jumpbuffer -= 1
			}
			if this.jumpbuffer>0 ? {
				if this.jumpframes>0 ? {
					this.jumpframes=0
					elf.audio.play("j0.wav")
					this.jumpbuffer=0
					this.aircounter=0
					this.spd.y=2
				} else {
					if walls.x!=0 ? {
						elf.audio.play("j0.wav")
						this.jumpbuffer=0
						this.spd.y=2.0
						this.spd.x=walls.x*(maxrun+1)
					}
				}
			}

			// dashing
			if dash ? {
				if this.remainingjumps>0 ? {
					elf.audio.play("dash.wav")
					shake=10
					this.remainingjumps-=1
					this.dashframes=6
					this.dasheffectframes=10
					d_full ::= 4
					dir := input
					if dir.x==0&&dir.y==0?{
						dir = vec2(1-this.flip.x*2,0)
					} else dir = dir:norm()
					this.spd=dir*d_full
					this.dashspd=dir*2
					this.dashacc=vec2(1.1,1.1):norm()
					if this.spd.y>0?{
						this.dashspd.y*=0.75
					}
				}else{
					// brrt...
				}
			}
		}
		this:move(this.spd)
	}
}

Key={
	_tag="key"
	_tile=2
	init=fun()?{
		this.tile=Key._tile
	}
	tick=fun()?{
		if this:overlaps(player) ? {
			spawn_death_particles(this)
			this.dead=true
		}
	}
	draw=fun()?{
		spr(this.tile,this.x,this.y+(sin(total_time*PI*0.8)+1)*2)
	}
}

check_walkable_tile = fun(x,y) ? {
	tile_x := ntoi(floor(iton(x) / 8))
	tile_y := ntoi(floor(iton(y) / 8))
	key := ""+tile_x+";"+tile_y
	tile := game.tilemap[key]
	--> tile
}

Skull={
	_tag="skull"
	init=fun()?{
		this.tile=16*2
		this.walkframes=0
	}
	tick=fun()?{
		this.walkframes=30
		// if this.walkframes<=0?{
		// 	if random()*1000 < 10 ? {
		// 		this.walkframes = 2+random()*4
		// 		this.flip.x=random()*1000<500
		// 	}
		// }
		if this.walkframes>0?{
			this.walkframes-=1
			dir ::= 1 - this.flip.x * 2
			halfw ::= this.w*0.5
			checkx ::= this.x+halfw + dir*halfw*1.3
			checky ::= this.y-2
			tile ::= check_walkable_tile(checkx,checky)
			if tile==nil?{
				dir*=-1
				this.flip.x^=1
			}
			this.spd.x = dir*0.1
		}
		if this:overlaps(player) ? {
			this.dead=true
			kill_player()
		}
		this:move(this.spd)
	}
}