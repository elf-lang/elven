UPSCALE 		 ::= 2
BASE_RES_X 		= 320
BASE_RES_Y 		= 240
WINDOW 			= new elf.gfx.Window("My Little Game",BASE_RES_X,BASE_RES_Y,UPSCALE)

// display_0 := WINDOW:get_frame_buffer(WINDOW)
// display_1 := elf.video.new_frame_buffer(WINDOW)

elf.audio.init()

EDITOR_MODE 	= false
KEY_MOVE_UP    = 'W'
KEY_MOVE_DOWN  = 'S'
KEY_MOVE_LEFT  = 'A'
KEY_MOVE_RIGHT = 'D'
KEY_ATTACK     = 'X'
KEY_DASH       = ' '
// KEY_JUMP       = ' '

KEY_DOWN 		= elf.gfx.Window.DOWN
KEY_PRESSED 	= elf.gfx.Window.PRESSED
KEY_RELEASED 	= elf.gfx.Window.RELEASED

// in order
scripts := {
	"math",
	"rnd",
	"assets",
	"collisions",
	"view",
	"editor",
	"particle",
	"sparks",
	"effects",
	"projectiles",
	"timing",
	"player",
	"enemies",
	"tilemap",
	"clouds",
}

for script = scripts[...] ? {
	path := ".\\scripts\\" + script + ".elf"
	elf.load_file(path)
}

play_audio_asset("ambience")
play_audio_asset("music")


player	= nil
trees    = {}
dead		= false
transition = 0
won 		= false

VIEW.set_camera_pos(0,0)
load_level = fun(index) ? {
	index ?= 0

	elf.pf("loading level: ", index)


	save_file := elf.read_file("levels\\" + index + ".elf")
	level := elf.const_expr(save_file)

	// level := elf.load_expr("levels\\" + index + ".elf")
	if level ? {
		tiles = level.tiles
		offgrid_tiles = level.offgrid_tiles
	}

	tiles ?= {}
	offgrid_tiles ?= {}
	run_autotiler()

	projectiles = {}
	enemies = {}
	particles = {}
	sparks = {}
	trees = {}
	player = nil
	dead = false

	spawners := query_level("spawners",0,true):merge_array(query_level("spawners",1,true))
	for spawner = spawners[...] ? {
		if spawner.variant == 0 ? {
			player = new Player(spawner.pos,vec2(8,15))
		} else if spawner.variant == 1 ? {
			add_enemy(spawner.pos)
		}
	}
	trees = query_level("large_decor",2,true)
}

load_level()

player_dead = fun() ? {
	if dead == false ? {
		transition = -60
	}
	dead = true
}

highest_time := 0
lowest_time := 10000

total_time := 0
background_image := get_image_assets("background")
draw_profiler_data := false

while WINDOW:poll() ? {
	_debug_timer := elf.get_clock_time()
	time ::= WINDOW.time

	mouse_x 					:= WINDOW.mouse_x
	mouse_y 					:= WINDOW.mouse_y
	trans2d 					:= VIEW.transform2d
	scale 					:= trans2d.scale.x
	offset_x 				:= trans2d.offset.x
	offset_y 				:= trans2d.offset.y
	tile_size 				:= get_tile_size()
	mouse_world_x 			:= (mouse_x - offset_x) / iton(trans2d.scale.x)
	mouse_world_y 			:= (mouse_y - offset_y) / iton(trans2d.scale.y)
	mouse_tile_x 			:= mouse_world_x / tile_size
	mouse_tile_y 			:= mouse_world_y / tile_size

	if WINDOW.keys['Q'] & KEY_RELEASED ? {
		EDITOR_MODE ^= 1
	}

	transition = min(30,transition+1)

	// was_alive := dead != 0
	// dead = max(0,dead-1)
	// if was_alive && dead == 0 ? {
	// 	transition = -60
	// }

	if WINDOW.keys['R'] & KEY_PRESSED ? {
		transition = -60
	}
	if transition == 30 && won ? {
		transition = -60
	}
	if transition == 0 ? {
		load_level()
	}

	// WINDOW:draw_rect(0,0,BASE_RES_X,BASE_RES_Y, 14,219,248,255)

	for tree = trees[...] ? {
		rect = new Rect(tree.pos.x,tree.pos.y,23,13)
		if random() * 49999 < rect.w * rect.h ? {
			pos := vec2(rect.x,rect.y) + vec2(rect.w,rect.h) * random()

			add_leaf_particle(pos)
		}
	}

	enable_tick := true
	if EDITOR_MODE ? {
		enable_tick = false
	}

	VIEW.tick(time)
	if enable_tick ? {
		tick_clouds(time)
		iff dead ? if player ? player:tick(time)
		tick_enemies(time)
		tick_projectiles(time)
		tick_sparks(time)
		tick_particles(time)
	}


	WINDOW:set_color(255,255,255,255)
	WINDOW:set_add_color(0,0,0,0)
	WINDOW:set_center(0,0)
	WINDOW:set_rotation(0,0)


	WINDOW:set_src_image(background_image)
	WINDOW:draw_image(0,0,background_image.width,background_image.height)

	draw_clouds()

	// begin camera view
	set_camera_view()

	draw_tilemap()

	draw_enemies()

	iff dead ? {
		if player ? {
			player:draw()
		}
	}

	draw_projectiles()
	draw_sparks()
	draw_particles()


	// reset transform and draw UI
	WINDOW:set_scale(1,1)
	WINDOW:set_offset(0,0)
	WINDOW:set_color(0,0,0,255)

	if transition > -30 && transition < 30  ? {
		WINDOW:draw_rect(0,BASE_RES_Y*(transition/30.0),BASE_RES_X,BASE_RES_Y)
	}

	if EDITOR_MODE ? {
		EDITOR.draw()
	}

	if draw_profiler_data ? {
		secs := elf.get_time_diff_s(_debug_timer)
		lowest_time = min(lowest_time,WINDOW.time)
		highest_time = max(highest_time,WINDOW.time)
		text := "" + secs * 1000.0 + "ms, " + (1.0 / time) + "fps, " + (1.0/highest_time) + "fps(h), " + (1.0 / lowest_time) + "fps(l)"
		WINDOW:draw_text(text, 1,1, 0,0,0,255)
		WINDOW:draw_text(text, 0,0, 0,255,0,255)
	}

	total_time += time
}

save_level = fun() ? {
	elf.pf("saving!")
	no_tombs = fun(tab) ? {
		keys := tab:keys()
		res := {}
		for key = keys[...] ? {
			res[key] = tab[key]
		}
		--> res
	}
	no_keys = fun(tab) ? {
		res := {}
		for i = tab[...] ? {
			res:add(i)
		}
		--> res
	}

	file ::= elf.open_file("levels\\0.elf","wb")
	elf.unload(file,{
		"tiles" = no_tombs(tiles),
		"offgrid_tiles" = no_keys(offgrid_tiles),
	})
	elf.close_file(file)
}

save_level()