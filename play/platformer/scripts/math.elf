PI		= 3.14159
TAU 	= 6.28318
PI90 	= PI * 0.50
PI45 	= PI * 0.25
PI180 = PI * 1.0
PI360 = PI * 2.0

TODEG = 1.0	/	PI	*	180.0

todeg = fun(x) ? ((iton(x) / PI) * 180.0)

sign_or_zero = fun(x) {
	if x < 0 ? 			--> -1;
	else if x > 0 ? 	-->  1;
	else 					-->  0;
}

/* todo: make these instrinsics */
abs = fun(x,y) ? { if x < 0 ? -->  -x else --> x }
min = fun(x,y) ? { if x < y ? --> 	x else --> y }
max = fun(x,y) ? { if x > y ? --> 	x else --> y }

saturate = fun(x) ? {
	if x < 0. ? leave 0.
	if x > 1. ? leave 1.
	leave x
}

lerp 		= fun(x,y,z) 		? (y + x * (z - y))
unlerp 	= fun(x,y,z) 		? ((x - y) / (z - y))
map 		= fun(x,y,z,w,v) 	? lerp(unlerp(x,y,z),w,v)
mix 		= lerp
unmix 	= unlerp
remix 	= map


/* todo: make these intrinsic */

vec3__add 	= fun(that) ? vec3(this.x+that.x,this.y+that.y,0)
vec3__sub 	= fun(that) ? vec3(this.x-that.x,this.y-that.y,0)
vec3__mul 	= fun(that) ? vec3(this.x*that.x,this.y*that.y,0)
vec3__div 	= fun(that) ? vec3(this.x/that.x,this.y/that.y,0)
vec3__add1 	= fun(that) ? vec3(this.x+that,this.y+that,0)
vec3__sub1 	= fun(that) ? vec3(this.x-that,this.y-that,0)
vec3__mul1 	= fun(that) ? vec3(this.x*that,this.y*that,0)
vec3__div1 	= fun(that) ? vec3(this.x/that,this.y/that,this.z/that)

vec3_metatab = fun() ? ({
	set = fun(x,y,z) ? {
		x ?= 0
		y ?= 0
		z ?= 0
		this.x = x
		this.y = y
		this.z = z
	}
	clone = fun() ? vec3(this.x,this.y,this.z),

	x = fun(x) ? vec3(x,this.y,this.z),
	y = fun(y) ? vec3(this.x,y,this.z),
	z = fun(z) ? vec3(this.x,this.y,z),

	abs = fun() ? vec3(abs(this.x),abs(this.y),abs(this.z)),

	eq = fun(that) ? (this.x==that.x&&this.y==that.y&&this.z==this.z),

	__add 	= vec3__add, 	add = vec3__add,
	__sub 	= vec3__sub, 	sub = vec3__sub,
	__mul 	= vec3__mul, 	mul = vec3__mul,
	__div 	= vec3__div, 	div = vec3__div,
	__add1 	= vec3__add1, add1 = vec3__add1,
	__sub1 	= vec3__sub1, sub1 = vec3__sub1,
	__mul1 	= vec3__mul1, mul1 = vec3__mul1,
	__div1 	= vec3__div1, div1 = vec3__div1,

	lenSq = fun() ? (this.x*this.x+this.y*this.y+this.z*this.z)

	len = fun() ? sqrt(this:lenSq()),

	dot = fun(that) ? (this.x*that.x + this.y*that.y + this.z*that.z),

	angle = fun() ? atan2(this.y,this.x)

	angleInDegrees = fun() ? atan2(this.x,this.y)*TODEG,

	mix = fun(that,ratio) ? {
		leave vec3(lerp(ratio,this.x,that.x),
		lerp(ratio,this.y,that.y),
		lerp(ratio,this.z,that.z))
	},

	lerp = fun(that,ratio) ? {
		leave this:mix(that,ratio)
	},

	floor = fun() ? vec3(floor(this.x),floor(this.y),floor(this.z)),

	norm = fun() ? {
		l := this:len()
		if l != 0 ? {
			--> this:div1(l)
		} else --> vec()
	}

	dir = fun() ? this:div1(this:len()),

	cross = fun(that) ? {
		leave vec3(	this.y*that.z - this.z*that.y,
		this.z*that.x - this.x*that.z,
		this.x*that.y - this.y*that.x )
	}

	perp = fun() ? (this:cross(this))

	//-1,0, 0,1
	perp2d = fun() ? {
		leave vec2(this.y,-this.x)
	}

	transform2d = fun(x,y) ? {
		leave vec2(this.x * x.x + this.y * x.y,
		this.x * y.x + this.y * y.y)
	}

	rotateByVec2d = fun(v) ? {
		leave vec2(this.x * v.x - this.y * v.y,
		this.x * v.y + this.y * v.x)
	}

	rotateByAngle2d = fun(angle) ? {
		let sinAngle = sin(angle)
		let cosAngle = cos(angle)
		leave vec2(this.x * cosAngle - this.y * sinAngle,
		this.x * sinAngle + this.y * cosAngle)
	}
})

vec3__ = vec3_metatab()

vec3 = fun(x,y,z) ? elf.set_meta({"x"=x,"y"=y,"z"=z},vec3__)

vec2 = fun(x,y) ? vec3(x,y,.0)

vec = fun(x) ? {
	/* todo: make this better */
	// if x != nil ? {
	// 	let _x = x.x if _x == nil ? _x = 0.
	// 	let _y = x.y if _y == nil ? _y = 0.
	// 	let _z = x.z if _z == nil ? _z = 0.
	// 	leave vec3(_x,_y,_z)
	// }
	leave vec3(.0,.0,.0)
}


LEFT  = vec3(-1, 0, 0)
RIGHT = vec3( 1, 0, 0)
UP    = vec3( 0, 1, 0)
DOWN  = vec3( 0,-1, 0)

// min ?= -PI
// max ?= +PI
// ref ?=  UP
rnddir2 = fun (min,max,ref) ? {
	let ang = atan2(ref.y,ref.x) + mix(min,max,rnd(0.,1000.)/1000.)
	leave vec3(cos(ang),sin(ang),0.)
}
