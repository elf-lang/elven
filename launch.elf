// elf.change_work_dir("W:\\MicroRJ\\platformer")
load "image.elf"
#eof
elf.change_work_dir("W:\\MicroRJ\\platformer")
load "main.elf"
// load "monster.elf"
#eof

Number = {
	__new = fun(num) ? {
		this.num = num ?? 0
	}
	__add1 = fun(num) ? {
		ret new Number(this.num + num)
	}
}
let some_thing = new Number()
some_thing += 1
elf.pf(some_thing)
#eof

defer {
	elf.pf("AT THE END")
}
elf.pf("AT THE START")
#eof

load "tests\\nil.elf"
load "tests\\if.elf"
load "tests\\fun.elf"
load "tests\\loops.elf"
load "tests\\prec.elf"



// - 	GOAL TODAY:
//	- 	x-- get games working!
//
// -	xx closures, we need capts
//
//	- 	x- parse.c: defer blocks, do while loops
//		we need to fix defer blocks so that they
//		are actually emitted properly...
//
//	- 	parse.c: range expression desugaring
//	-	parse.c: ternary expressions
//	-	parse.c: conditionals, introduce conditional
//		expression, they wrap some other expression,
//		if the expression is nil, the rest isn't executed
//		and the result is nil, so the user can pair it
//		up with the nil or operator.
//
//		parse?:name()
//		parse:name?()
//		parse?.name
//
//	-  sublime syntax highlight
//
//	-	xx break / continue, they should take the for loop
//		as the operand
//
//	-	x- parse.c: infinite ranges, nameless loops
//	-	xxx- parser.c: clean up parser
//
//	-  change declaration syntax, from 'let' to ':='
//	-  set_line function to avoid having to pass in the
//		line every single time
//
//	-	core.c: calling a function should not be recursive
//	-	parse.c: type annotations
//	-  gen.c: specialized bytecode for known types
//	-	parse.c: default parameter values
//	-  core.c & parse.c & gen.c: array index instrinsics!
//	-	parse.c: make it so that global references aren't implicit,
//		this tends to not be a big problem but it does get
//		annoying
//	-	lib_sockets.c: sockets...
//	-	lib_threads.c: threading...
//	-	parse.c: meta postprocessor?
//	-	core.c: generate profiling data so that we can
//		visualize it, John Blow style.
//	- 	help.h: rename to base.h, put core type defs
//		in there
//	- 	core.c: calling functions should not be recursive
//	-	core.c: figure out what to do with the vector
//		values idea, do we want every value to
//		be a vector? (postpone)
//	-	parse.c: block strings, inplace formatted strings
//		shader =
//		"""
//		void main() {
//			gl_FragColor = vec3(1,2,3)
//		}
//		"""
// - 	add an end of line token instead of
//		using passive hinting? (postpone)
// - 	revise the table core lib, should
//		we just add the array type?
//	-  can we get color logging?
//	-  x- delete un-used files, elf-web.c,lcrtlib.c,elf-cli.c?
//	-  cleanup core file
//	-	clean up globals
//	-	proper test suite
//	- 	#array, #index, #value registers

//	-	xx !! and ??
//	-	allow the user to refer to for loops by name
// -  xx proper assignments!
//	-  parse.c: #syntax What happens when you have multiple expressions
//		on a single line?
//		They just get evaluated, or discarded,
//		but that should be a syntax error
//
//
// -  byte.c: fix stupid bytecode!
// -  byte.h & core.c: get rid of yield, delay, and leave instructions they
//		are no longer in use!
//	- 	parse.c & gen.c: 'then' branch will require us to
//		move the entire if elif thing to the generator.
//	-  parse.c & gen.c: multi-returns
//	-  parse.c & gen.c: change the calling convetion so that
//		the 'this' param comes first, then the function then
//		arguments, and fully expose these registers.
//		Putting 'this' as the first argument means it'll be
//		the default return value without having to emit additional
//		code. (postpone)
//	- 	xx elifs
// -	xx fields, indices, metafield (postfix expressions)
// -  xx array for-loops, generic for loops
// -	xx function parameters, 'this'
//	-	re-introduce groups, we need them for proper code gen now
//	-  fix short circuiting bug
// -	merge module and state?
// -	clean up, delete old files
// 		- 	get rid of elf-web.c
// 		- 	get rid of jit toy we have 'c66' as a
//				much better reference
// 		- 	get rid of error.h, or make it better
//	-  figure out whether we want function types or not,
//		then:
//			- 	determine what a file really is and whether we
//				need them...
//			- 	Will prototypes always remain loaded, can get
//				rid of the unused ones?
//			-	If files are a thing, will a file keep all prototypes
//				loaded, even when not in use?
//			- 	If there are no files, do we keep the source code for
//				each file?
//			-	If prototypes are dynamic, will they become objects too?
//				Or will they get treated separately?
// 		-	Will bytecode be allocated per prototype or still be
//				emitted to the same buffer?
// - 	organize library, organize elf.h
//		-	figure what the API for the core
//			library will be, setup some constraints
//			it should adhere to.
//		-	core lib function that tells you whether
//			an object is visible, and tells the path.
//
// - bytecode should be much smaller
//
// - use linear allocator for internal stuff, like
//	allocating instructions and stuff...
//
// networking library
// trace-recording
// self-optimization
//		- inlining
//		- optimize table lookups
//		- optimize object allocation
// x64 compilation?
//
//
