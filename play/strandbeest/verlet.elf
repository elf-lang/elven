
Particles = {}
Sticks 	 = {}
Rotors    = {}

CurrentlyHoveringParticle = nil
CurrentlyDraggingParticle = nil
WasCurrentlyDraggingParticleLocked = false


NewParticle = fun(pos,vel,label) ? {
	pos ?= vec()
	vel ?= vec()
	let p = {
		oldPos = pos - vel
		curPos = pos
		size   = 8
		locked = false
		label  = label
	}
	Particles:add(p)
	leave p
}



NewStick = fun(p0,p1,length,color,label) ? {
	length ?= (p1.curPos-p0.curPos):len()
	color ?= .WHITE
	let s = {p0=p0,p1=p1,length=length,color=color,label=label}
	Sticks:add(s)
	leave s
}



NewRotor = fun(crank,name) ? {
	let r = {
		crank = crank
		cycle = 0.
	}
	Rotors:add(r)
	leave r
}



TickParticles = fun() ? {
	let delta = min(MAX_DELTA,.GetFrameTime())
	for i = 0..Particles:tally() ? {
		let p = Particles:idx(i)
		if p.locked ? continue
		// let v = p.curPos-p.oldPos
		// v -= v*.5*delta
		// v.y -= 100.*delta
		// p.oldPos = p.curPos
		// p.curPos = p.curPos+v
		// this is so silly, like what's the point
		// of even using a dynamic language if you
		// gotta do this crap anyways...
		let xvelocity = p.curPos.x - p.oldPos.x
		let yvelocity = p.curPos.y - p.oldPos.y
		xvelocity -= xvelocity * .5 * delta
		yvelocity -= yvelocity * .5 * delta
		yvelocity -= 100. * delta
		p.oldPos = p.curPos:clone()
		p.curPos.x += xvelocity
		p.curPos.y += yvelocity
	}
}


ApplyTorque = fun(stick,force,bias) ? {
	let norm = (stick.p1.curPos-stick.p0.curPos):dir():perp2d()
	stick.p0.oldPos -= norm*force*(1-bias)
	stick.p1.oldPos -= norm*force*(0+bias)
}


TickConstraints = fun() ? {
	let delta = min(MAX_DELTA,.GetFrameTime())
	for i = 0..Sticks:tally() ? {
		let stk = Sticks:idx(i)
		let p0 = stk.p0
		let p1 = stk.p1
		let dst = p1.curPos - p0.curPos
		let dir = dst:dir()
		let trm = dir*(dst:len()-stk.length)*.5
		iff p0.locked ? p0.curPos += trm
		iff p1.locked ? p1.curPos -= trm
	}
	for i = 0..Particles:tally() ? {
		let p = Particles:idx(i)
		let v = p.curPos - p.oldPos

		let yMax = .GetScreenHeight()*.5
		let xMax = .GetScreenWidth()*.5
		if p.curPos.y < -yMax ? {
			p.curPos.y = -yMax
		} elif p.curPos.y > +yMax ? {
			p.curPos.y = +yMax
		} then {
			p.oldPos = p.curPos + v*.1
		}
		if p.curPos.x < -xMax ? {
			p.curPos.x = -xMax
		} elif p.curPos.x > +xMax ? {
			p.curPos.x = +xMax
		} then {
			p.oldPos.x = p.curPos.x + v.x*.1
		}
	}
}


DrawParticles = fun() ? {
	for i = 0..Particles:tally() ? {
		let p = Particles:idx(i)
		let color = .WHITE
		if p.locked ? color = .GRAY
		.DrawCircle(p.curPos,p.size,color)
		if p.label != nil ? {
			.DrawText(p.label,p.curPos.x,p.curPos.y+10,10,color)
		}
	}
	for i = 0..Sticks:tally() ? {
		let stk = Sticks:idx(i)
		.DrawLine(stk.p0.curPos,stk.p1.curPos,2,stk.color)

		let dif = stk.p1.curPos - stk.p0.curPos
		let cen = stk.p0.curPos + dif * .5
		if stk.label != nil ? {
			.DrawText(stk.label,cen.x,cen.y,10,stk.color)
		}
		let norm = dif:dir():perp2d()
		.DrawLine(cen,cen+norm*10.,2,.RED)
	}
}
