PI      ::= 3.14159
TAU     ::= 6.28318
E       ::= 2.71828
k_isqrt ::= 0.70710678118 // 1.0 / sqrt(2.0)

rgb ::= fun(r,g,b) ? ({r=r,g=g,b=b,a=255})
WHITE = rgb(255,255,255,255)
BLUE  = rgb(32,32,200,255)
GREEN = rgb(0,128,32,255)
RED   = rgb(255,32,0,255)

UPSCALE  	::= 4
WIND_W   	::= 128 // 320
WIND_H   	::= 128 // 240
ASPECT_R 	::= WIND_W / iton(WIND_H)
CENTER_X 	::= WIND_W / 2
CENTER_Y 	::= WIND_H / 2
TILE_SIZE 	::= 8
EDITOR_MODE=false

load "math.elf"

elf.audio.init()
VIEW ::= new elf.gfx.Window("Collision!",WIND_W,WIND_H,UPSCALE)

// todo: if you set this to a local,
// the editor's camera is is the same
// as this...
GAME_CAMERA = new Camera(vec2(0,VIEW.res_y),vec2(1,-1))

PRESSED  = elf.gfx.Window.PRESSED
DOWN 		= elf.gfx.Window.DOWN
RELEASED = elf.gfx.Window.RELEASED

load "editor.elf"
editor := new Editor(VIEW,GAME_CAMERA,8)

// #test "hard binding error"
// warnings := #getwarnings()
// #assert warnings[0] == 0
MAX_NJUMPS=1

player_image 	::= elf.gfx.load_image("player.png")
tiles_image 	::= elf.gfx.load_image("tiles.png")

bubbles := {}
wind_particles = {}
for i = 0...8 ? {
	bubbles:add({
		random=random(),
		x=random()*9999,
		y=random()*9999,
	})
	wind_particles:add({
		random=random(),
		x=random()*9999,
		y=random()*9999,
	})
}

sprite ::= {
	__new=fun(type,x,y,w,h) ? {
		this.type=type
		this.x=x
		this.y=y
		this.xrem=0
		this.yrem=0
		this.w=w??8
		this.h=h??8
		this.color=WHITE
		if(type=="spikes")?{
			this.color=RED
		}
		this.spd=vec2()
		this.remainingdash=0
		this.dashaccel=vec2()
		this.dashtargetaccel=vec2()
		this.dash_effect_time=0
		this.remainingjumps=MAX_NJUMPS
		this.jumpbuffer=0
		this.aircounter=0
		this.xflip=0
		this.imageframe=0
		this.framecounter=0
		// elf.pf("new sprite: ", this)
	}
	draw=fun()?{
		c := this.color ?? WHITE
		VIEW:set_color(c.r,c.g,c.b,c.a)
		if this.type=="player" ? {
			this.framecounter += 1
			if this.framecounter>8 ?{
				this.framecounter=0
				this.imageframe += 1
				this.imageframe %= 3
			}
			VIEW:set_src_image(player_image)
			VIEW:set_src_rect(this.imageframe*8,0,8,8)
			x := this.x
			y := this.y
			if this.imageframe % 2 == 1 ? {
				y -= 1
			}
			VIEW:draw_image(x, y, 8, 8, this.xflip, 0)
		}else if this.type=="tile"?{
			VIEW:set_src_image(tiles_image)
			VIEW:set_src_rect(0,8*2,8,8)
			x := this.x
			y := this.y
			VIEW:draw_image(x, y, 8, 8)
		}else{
			VIEW:draw_rect(this.x, VIEW.res_y - this.y - this.h, this.w, this.h)
		}
	}
	tick=fun(time)?{
		dash ::= VIEW.keys[' '] & PRESSED
		input := vec2()

		if VIEW.keys['A'] & DOWN ? input.x -= 1;
		if VIEW.keys['D'] & DOWN ? input.x += 1;
		if VIEW.keys['S'] & DOWN ? input.y -= 1;
		if VIEW.keys['W'] & DOWN ? input.y += 1;
		if VIEW.keys['W'] & PRESSED ? {
			this.jumpbuffer = 4
		} else if this.jumpbuffer > 0 ? {
			this.jumpbuffer -= 1
		}

		on_ground := this:get_wall_normal(0,1).y == 1

		if on_ground ? {
			this.aircounter=0
			this.color=RED
			// restore jumps
			if this.remainingjumps<MAX_NJUMPS ? {
				this.remainingjumps=MAX_NJUMPS
				this.color=GREEN
			}
		} else {
			this.aircounter+=1
			this.color=WHITE
		}


		this.dash_effect_time -=1
		if this.remainingdash > 0 ? {
			// init_object(smoke,this.x,this.y)
			this.remainingdash -= 1
			this.spd.x=appr(this.spd.x,this.dashtargetaccel.x,this.dashaccel.x)
			this.spd.y=appr(this.spd.y,this.dashtargetaccel.y,this.dashaccel.y)
		} else {
			maxrun := 1
			accel := 0.5
			deccel := 0.13
			on_ice := false

			if on_ground ? {
				if on_ice ? {
					accel=0.05
				}
			} else {
				accel=0.4
			}
			if abs(this.spd.x) > maxrun ? {
				this.color=BLUE
				this.spd.x=appr(this.spd.x,signz(this.spd.x)*maxrun,deccel)
			} else {
				// this.color=GREEN
				this.spd.x=appr(this.spd.x,input.x*maxrun,accel)
			}

			if this.spd.x != 0 ? {
				this.xflip = this.spd.x < 0
			}


			// gravity
			maxfall := 2
			gravity := 0.21
			if this.spd.y >= 0.15 ? {
				gravity *= 0.60
			}
			nearwall := this:get_wall_normal(1).x
			if input.x!=0 && nearwall!=0 ? {
				maxfall=0.45
			}

			iff on_ground ? {
				this.spd.y=appr(this.spd.y,-maxfall,gravity)
			}

			// -- jump
			if this.jumpbuffer>0 ? {
				if this.aircounter==0 ? {
					// we jumped when on the floor
					// psfx(1)
					elf.audio.play("j0.wav")
					this.jumpbuffer=0
					this.aircounter=0
					this.spd.y=2
					// init_object(smoke,this.x,this.y+4)
				} else if this.aircounter > 5 ? {
					// we jumped again when in the air, check
					// if we have wall supports, if so jump
					// from them
					wall_dir := this:get_wall_normal(1).x
					if wall_dir!=0 ? {
						elf.audio.play("j0.wav")
						// psfx(2)
						this.jumpbuffer=0
						this.spd.y=2
						this.spd.x=-wall_dir*(maxrun+1)
						// if not this.is_ice(wall_dir*3,0) {
						// 	init_object(smoke,this.x+wall_dir*6,this.y)
						// }
					}
				}
			}

			// dashing
			if dash ? {
				if this.remainingjumps>0 ? {
					elf.audio.play("dash.wav")
					this.remainingjumps-=1
					this.remainingdash=8
					this.dash_effect_time=10
					d_full ::= 5
					d_half ::= d_full*k_isqrt
					if input.x!=0 ? {
						// todo: just normalize the input?
						if input.y!=0 ? {
							this.spd.x=input.x*d_half
							this.spd.y=input.y*d_half
						} else {
							this.spd.x=input.x*d_full
							this.spd.y=0
						}
					} else if input.y!=0 ? {
						this.spd.x=0
						this.spd.y=input.y*d_full
					} else {
						this.spd.x=this.xflip
						this.spd.y=0
					}

					this.dashtargetaccel.x=2*signz(this.spd.x)
					this.dashtargetaccel.y=2*signz(this.spd.y)
					this.dashaccel.x=1.5
					this.dashaccel.y=1.5
					if this.spd.y!=0 ? {
						this.dashaccel.x*=k_isqrt
					}
					if this.spd.x!=0 ? {
						this.dashaccel.y*=k_isqrt
					}
				}else{
					// brrt...
				}
			}

			// move := this.m + this.spd
		}
		this:move(this.spd)
	}
	overlaps=fun(that,x_border,y_border)?{
		x_border ?= 0
		y_border ?= 0
		--> this.x + this.w > that.x - x_border
		&&  this.y + this.h > that.y - y_border
		&&  that.x + that.w > this.x - x_border
		&&  that.y + that.h > this.y - y_border
	}
	// todo: this doesn't return the wall normal for the
	// x axis
	get_wall_normal=fun(x_border,y_border)?{
		x_border ?= 0
		y_border ?= 0
		normal := vec2()
		for that = static_things[...] ? {
			if that == nil ? continue;
			if this:overlaps(that,x_border,0) ? {
				normal.x = (this.x < that.x) * 2 - 1
				break
			}
		}
		for that = static_things[...] ? {
			if that == nil ? continue;
			if this:overlaps(that,0,y_border) ? {
				normal.y = (this.y > that.y) * 2 - 1
				break
			}
		}
		--> normal
	}
	move=fun(move)?{
		for axis = 0,1 ? {
			if axis == 0 ? {
				this.xrem += move.x
				mov := floor(this.xrem)
				this.xrem -= mov
				this.x += mov
			} else {
				this.yrem += move.y
				mov := floor(this.yrem)
				this.yrem -= mov
				this.y += mov
			}

			tiles ::= {}
			for that = static_things[...] ? {
				if that == nil ? {
					continue
				}
				if this:overlaps(that) ? {
					if that.type == "spikes" ? {
						this.hit_spikes = true
					}
					this.colliding = true
					that.colliding = true
					if axis == 0 ? {
						if move.x > 0 ? {
							this.x = that.x - this.w;
						} else if move.x < 0 ? {
							this.x = that.x + that.w;
						}
					} else {
						if move.y > 0 ? {
							this.y = that.y - this.h;
						} else if move.y < 0 ? {
							this.y = that.y + that.h;
						}
					}
				}
			}

			// if this.x < 0 ? this.x = 0;
			// else if this.x + this.w > VIEW.res_x ? this.x = VIEW.res_x - this.w;
			// if this.y < 0 ? this.y = 0;
			// else if this.y + this.h > VIEW.res_y ? this.y = VIEW.res_y - this.h;

		}
	}
}

static_things={}
spikes={}
sprites={}
platforms={}
total_time=0
jump_buffer=1
wall_sliding=false
player_spawn:=vec2(TILE_SIZE*2,TILE_SIZE*2)
new_player=fun()?{
	player?=new sprite("player",0,0,8,8)
	player.x=player_spawn.x
	player.y=player_spawn.y
	player.v=vec2()
	player.m=vec2()
}
new_player()
sprites:add(player)


coords_to_tile ::= fun(x,y) ? {
	tile_x ::= ntoi(floor(x / TILE_SIZE))
	tile_y ::= ntoi(floor(y / TILE_SIZE))
	key ::= tile_y << 16 | tile_x
	if tile_y >> 16 ? {
		elf.pf("invalid tile coordinates, too large: x,y = ", x, ", ", y)
		--> nil
	} else {
		--> {key=key,tile_x=tile_x,tile_y=tile_y}
	}
}
unplace_rect ::= fun(x,y) ? {
	info ::= coords_to_tile(x,y)
	tile_x ::= info.tile_x
	tile_y ::= info.tile_y
	key ::= info.key
	if static_things[key] ? {
		static_things:delete(key)
	}
}
place_rect ::= fun(x,y,thing) ? {
	info ::= coords_to_tile(x,y)
	if info ? {
		tile_x ::= info.tile_x
		tile_y ::= info.tile_y
		key ::= info.key
		thing ?= new sprite("tile",0,0,TILE_SIZE,TILE_SIZE)
		thing.x = tile_x*TILE_SIZE
		thing.y = tile_y*TILE_SIZE
		static_things[key] = thing
	}
}

for i = 0...20 ? {
	place_rect(i*TILE_SIZE,0)
}
for i = 0...15 ? {
	place_rect(0,i*TILE_SIZE)
}

// platforms:add(new sprite("platform",32,32,32,8))
// platforms:add(new sprite("platform",64,32,32,8))

spr_names := {"tile","spikes"}
cur_spr := "tile"
cur_spr_index := 0

view ::= VIEW
while view:poll() ? {


	time ::= view.time
	total_time += time


	// view:set_color(121,37,45,255)
	view:set_color(235,150,158,255)
	view:draw_rect(0,0,view.res_x,view.res_y)

	view:set_color(179,70,80,255)
	for bub = bubbles[...] ? {
		bub.x += 0.01 + sin(total_time * 0.1 * PI + bub.random) * 0.1
		bub.y -= 0.02
		rad := 4 + bub.random*8

		draw_x := bub.x % (view.res_x + rad*2) - rad*2
		draw_y := bub.y % (view.res_y + rad*2) - rad*2

		view:draw_circle(draw_x,draw_y,rad)
	}

	view:set_color(235,204,207,255)
	for par = wind_particles[...] ? {
		par.x += 0.01 + sin(total_time * 0.1 * PI + par.random) * 0.1
		par.y += 0.01

		rad := 1
		draw_x := par.x % (view.res_x + rad*2) - rad*2
		draw_y := par.y % (view.res_y + rad*2) - rad*2

		view:draw_rect(draw_x,draw_y,1,1)
	}

	if view.keys['S'] & PRESSED ? {
		cur_spr = spr_names:idx(cur_spr_index)
		cur_spr_index = (cur_spr_index + 1) % spr_names:tally()
		elf.pf("cur_spr: ", cur_spr)
	}
	// if player.hit_spikes ? {
	// 	new_player()
	// }

	view:set_color(255,255,255,255)
	for spr = sprites[...], static_things[...], platforms[...] ? {
		if spr != nil ? {
			spr.colliding = false
		}
	}
	for spr = sprites[...] ? {
		if spr ? {
			spr:tick(time)
		}
	}

	for plat = platforms[...] ? {
		move := vec2()
		if plat == platforms:idx(0) ? {
			move.y = sin(total_time*PI*0.5)*2
		} else {
			move.x = sin(total_time*PI*0.5)*2
		}
		plat.x+=move.x
		plat.y+=move.y
		for that = sprites[...] ? {
			iff plat:overlaps(that) ? {
				continue
			}
			plat.colliding = true
			that.colliding = true
			if plat.y < that.y ? {
				if that.v.y < 0 ? {
					that.y = plat.y + plat.h;
					that.v.y = 0
					that.v.x = 0
					that.m.x += move.x
					// that.x += move.x
					jump_buffer=1
				}
			}
		}
	}

	camera ::= GAME_CAMERA
	if EDITOR_MODE ? {
		camera = editor.camera
	}
	if GAME_CAMERA == editor.camera ? {
		elf.pf("this an error")
	}
	view:set_offset(camera.offset.x,camera.offset.y)
	view:set_scale(camera.scale.x,camera.scale.y)
	for spr = sprites[...], static_things[...], platforms[...] ? {
		if spr != nil ? {
			spr:draw()
		}
	}

	view:set_offset(0,0)
	view:set_scale(1,1)
	if view.keys['Q'] & PRESSED ? {
		EDITOR_MODE^=1
		elf.pf("EDITOR_MODE: ", EDITOR_MODE)
	}
	if EDITOR_MODE ? {

		editor.tile_placement_mode?=false
		if view.keys[' '] & PRESSED ? {
			editor.tile_placement_mode^=true
		}
		if editor.tile_placement_mode ? {
			mouse ::= editor:get_mouse_pos()
			if view.mouse[1] & DOWN ? {
				place_rect(mouse.x,mouse.y,new sprite(cur_spr,0,0,TILE_SIZE,TILE_SIZE));
			}
			if view.mouse[2] & DOWN ? {
				unplace_rect(mouse.x,mouse.y);
			}
		} else {
			editor:do_panning()
		}
		editor:draw()
		// } else {
		// 	if (view.mouse[1]|view.mouse[2]) & KEY_DOWN ? {
		// 		remove := false
		// 		if view.mouse[2] & KEY_DOWN ? {
		// 			remove = true
		// 		}

		// 		iff this.offgrid_mode ? {
		// 			pos := vec2(mouse_tile_pos_x,mouse_tile_pos_y)
		// 			if tile_placement_mode == "tiles" ? {
		// 				place_tile(mouse_tile_pos_x,mouse_tile_pos_y,this.current_tile_group_name,this.current_tile_variant,remove)
		// 			} else if tile_placement_mode == "grass" ? {
		// 				place_grass_tile(pos,this.current_tile_group_name,this.current_tile_variant,remove)
		// 			}
		// 		}
		// 	} else if (view.mouse[1]|view.mouse[2]) & KEY_RELEASED ? {
		// 		remove := false
		// 		if (view.mouse[2] & KEY_RELEASED) ? {
		// 			remove = true
		// 		}
		// 		if this.offgrid_mode ? {
		// 			add_offgrid_tile(vec2(mouse_subtile_pos_x,mouse_subtile_pos_y),this.current_tile_group_name,this.current_tile_variant,remove)
		// 		}
		// 	}
		// }
	}
}

#eof

// #worstbugever
	// omg, for some reason instead of using
	// a range, we  use a step, -1,0,2 will
	// trigger the most weird fatal bug ever,
	// please look into it, seems that also
	// the bug goes away if we keep steps but
	// we remove the if statement ofs_x == 0,
	// it has to do with ofs_x, because the
	// if statement can remain just not us
	// checking ofs
for ofs_y = -1...2 ? {
	for ofs_x = -1...2 ? {
		if ofs_x == 0 && ofs_y == 0 ? {
			continue
		}
		tile_x ::= ntoi(floor(ofs_x + that.x / TILE_SIZE))
		tile_y ::= ntoi(floor(ofs_y + that.y / TILE_SIZE))
		key ::= tile_y << 16 | tile_x
		if rects[key] ? {
			if that:overlaps(rects[key]) ? {
				results:add(rects[key])
			}
		}
	}
}
--> results