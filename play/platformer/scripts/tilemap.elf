tiles = {}
offgrid_tiles = {}

tile_size := 16
get_tile_size = fun() ? (tile_size)

tile_assets := get_image_assets("tiles")
solid_tiles := { "grass" = 1, "stone" = 1 }
dirty = false

query_level = fun(type,var,keep) ? {
	keep ?= true
	res := {}
	for tile = offgrid_tiles[...], tiles[...] ? {
		if tile == nil ? {
			continue
		}
		if tile.type == type && tile.variant == var ? {
			res:add({
				pos 		= vec2(tile.pos.x*tile_size,tile.pos.y*tile_size)
				type 	 	= type
				variant 	= var
			})
		}
	}
	--> res
}




variant_name_to_variant_index ::= {
	"top_left"      = 0
	"top_center"    = 1
	"top_right" 	 = 2

	"middle_left" 	 = 7
	"middle_center" = 5
	"middle_right"  = 3

	"bottom_left" 	 = 6
	"bottom_center" = 8
	"bottom_right"  = 4
}

same  ::= fun(cen,nei) ? (nei != nil && nei.type == cen.type)
air   ::= fun(cen,nei) ? (nei == nil)

regular_patcher := {
	// rules = {left,right,top,bottom}
	{variant = "top_left"			, rules = {air,same,air,same}},
	{variant = "top_center"			, rules = {same,same,air,same}},
	{variant = "top_right"			, rules = {same,air,air,same}},
	{variant = "middle_left"		, rules = {air,same,same,same}},
	{variant = "middle_center"		, rules = {same,same,same,same}},
	{variant = "middle_right"		, rules = {same,air,same,same}},
	{variant = "bottom_left"		, rules = {air,same,same,air}},
	{variant = "bottom_center"		, rules = {same,same,same,air}},
	{variant = "bottom_right"		, rules = {same,air,same,air}},
}

get_tile_key = fun(x,y) ? ("" + ntoi(x) + ";" + ntoi(y))

get_tile = fun(x,y) ? {
	--> tiles[get_tile_key(x,y)]
}

check_tile_solid = fun(pos) ? {
	tile_x := ntoi(floor(iton(pos.x) / tile_size))
	tile_y := ntoi(floor(iton(pos.y) / tile_size))
	tile := get_tile(tile_x,tile_y)
	--> tile !! solid_tiles[tile.type]
}

autotile := fun(x,y,patcher) ? {
	patcher ?= regular_patcher
	tile := get_tile(x,y)
	for param = patcher[...] ? {
		rules ::= param.rules
		iff rules[0](tile,get_tile(x-1,y)) ? {continue}
		iff rules[1](tile,get_tile(x+1,y)) ? {continue}
		iff rules[2](tile,get_tile(x,y+1)) ? {continue}
		iff rules[3](tile,get_tile(x,y-1)) ? {continue}
		var := variant_name_to_variant_index[param.variant]
		--> var
	}
	--> nil
}



add_offgrid_tile = fun(pos,type,var,remove) ? {
	remove ?= false
	if remove ? {
		elf.pf("removing offgrid tile: ", type, ", ", pos, ", ", var)
		new_offgrid_tiles := {}
		for tile = offgrid_tiles[...] ? {
			img := tile_assets[tile.type]:idx(tile.variant)
			w := img.width / iton(tile_size)
			h := img.height / iton(tile_size)
			if point_in_rect(pos.x,pos.y,tile.pos.x,tile.pos.y,w,h) ? {
				elf.pf("REMOVED TILE!")
			} else {
				new_offgrid_tiles:add(tile)
			}
		}
		offgrid_tiles = new_offgrid_tiles
	} else {
		elf.pf("adding offgrid tile: ", type, ", ", pos, ", ", var)
		offgrid_tiles:add({pos=pos,type=type,variant=var})
	}
}

place_tile = fun(x,y,type,variant,remove) ? {
	remove ?= false

	x = ntoi(x)
	y = ntoi(y)
	key ::= get_tile_key(x,y)

	changed := 0
	if remove == true ? {
		if tiles[key] ? {
			tiles:delete(key)
			changed = true
		}
	} else {
		if tiles[key] == nil ? {
			elf.pf("placing tile: ", x, ", ", y, ", key: ", key, ", type: ", type, ", variant: ", variant)
			tiles[key] = {
				type=type,
				variant=variant,
				pos=vec2(x,y)
			}
			changed = true
		}
	}
	if changed ? {
		dirty = true
	}
}

run_autotiler = fun() ? {
	for tile = tiles[...] ? {
		if tile == nil ? {
			continue
		}
		check := get_tile(tile.pos.x,tile.pos.y)
		if check ? {
			var ::= autotile(tile.pos.x,tile.pos.y)
			tile.variant = var ?? tile.variant
		} else {
			elf.pf("invalid tile: ", tile.pos)
		}
	}
}

draw_tilemap = fun() ? {
	// todo:
	if dirty ? {
		dirty = false
		run_autotiler()
	}

	pos := VIEW.get_camera_pos()
	size := VIEW.get_camera_size()
	x0 := ntoi(floor((pos.x - size.x * 0.5) / tile_size))
	y0 := ntoi(floor((pos.y - size.y * 0.5) / tile_size))
	y1 := ntoi(ceil((pos.y + size.y * 0.5) / tile_size))
	x1 := ntoi(ceil((pos.x + size.x * 0.5) / tile_size))

	if 1 ? {
		for tile = offgrid_tiles[...] ? {
			if tile == nil ? {
				continue
			}
			img ::= tile_assets[tile.type]:idx(tile.variant)
			WINDOW:set_src_image(img)
			WINDOW:draw_image(tile.pos.x*tile_size,tile.pos.y*tile_size)
		}
	}

	for ty = y0...y1 + 1 ? {
		for tx = x0...x1 + 1 ? {
			tile := get_tile(tx,ty)
			if tile == nil ? {
				continue
			}
			x := tx * tile_size
			y := ty * tile_size
			img ::= tile_assets[tile.type]:idx(tile.variant)
			WINDOW:set_src_image(img)
			WINDOW:draw_image(x,y)
		}
	}
}

get_overlapping_rects = fun(rect) ? {
	results ::= {}
	px = ntoi(floor(rect.x / tile_size))
	py = ntoi(floor(rect.y / tile_size))

	for oy = -1...2 ? {
		for ox = -1...2 ? {
			tx := px + ox
			ty := py + oy
			tile := get_tile(tx,ty)
			if tile == nil ? {
				continue
			}
			if solid_tiles[tile.type] ? {
				if rect:overlaps4(tx*tile_size,ty*tile_size,tile_size,tile_size) ? {
					results:add(new Rect(tx*tile_size,ty*tile_size,tile_size,tile_size))
				}
			}
		}
	}
	--> results
	// old way of doing it
	for tile = tiles[...] ? {
		if tile == nil ? {
			continue
		}
		if solid_tiles[tile.type] ?  {
			tile_rect ::= new Rect(
			,	tile.pos.x * tile_size
			,	tile.pos.y * tile_size
			,	tile_size
			,	tile_size )
			if rect:overlaps(tile_rect) ? {
				results:add(tile_rect)
			}
		}
	}
	--> results
}