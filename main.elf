load "tests.elf"

elf.change_work_dir("W:\\MicroRJ\\game2")
load "main.elf"
#eof

// #assert(1 == 2)


foo = fun(x) ? { --> x }
elf.pf(foo("HERE"))

#eof


#eof
#eof
#eof

tab := { a = 1 }
tab.a = 7
elf.pf(tab)
#eof


#eof


arr := {"a", "b", "c", "d", "e"}
for i = arr[...]  ? {
	elf.pf(#index, ": ", #value)
}

// for i = 0 ... 10 ? {
// 	elf.pf(i)
// }
#eof



// so one of the most used features of dynamic languages
// are maps, or hash tables, or the ability to map anything
// to anything.
// this is typically done with table-like objects, each table
// points to its own heap buffer, and has its own overhead.
// At runtime hundreds of tables are used and reused, tables
// that are recycled often tend to be smaller in size, perhaps
// 2 - 8 fields, hash-tables of this size are incredibly space
// inefficient.
// What if instead of creating a hash-table per object, we used
// the object itself as a key ?
//
//
//	name := {}
// name.x = 1
//
//	would become:
//
//	setglobalregistry(name, "x", 1)
//
//
//	here 'name''s pointer would get hashed along with 'x'
// and 1 would get stored in the global registry.
//
//
//	The global registry has the advantage that it can be
// large and thus space efficient, perhaps even reducing
// the need for constant GC'ing since keys can be copied
// there directly.
// This would mean we'd have a limit on key size.
//
// Let's say its 64.
//
//	So let's do 4 bytes for the pointer part, and 60 for
// the field part, which can be any other value as well.
//
// this_is_about_how_long_60_bytes_are_as_a_string_plenty_for_most_
//
//
// A 4096 table would produce a constant 0.25 MB footprint,
// which although large, would benefit from very little overhead,
// better memory locality and hash efficiency
// compared to having lots of smaller tables located randomly
// on the heap.
// Additionally, copying the strings directly would relieve the
// GC from strenuous garbage collection.
//
//	There also wouldn't be a need to have a specific table type,
// you could associate any object with any value.
//
//
//


N = 1000000
{
	global_registry = {}
	startcounter := elf.get_performance_counter()
	for i = ...N ? {
		new_obj := {}
		// this emits 3 additional function calls
		hashx := elf.registryhash64(new_obj, "x")
		global_registry[hashx] = 0
		hashy := elf.registryhash64(new_obj, "y")
		global_registry[hashy] = 1
		hashz := elf.registryhash64(new_obj, "z")
		global_registry[hashz] = 2
	}
	tookseconds := elf.get_performance_counter_elapsed_s(startcounter)
	elf.pf("global-registry took: ", tookseconds)
}
{
	startcounter := elf.get_performance_counter()
	for i = ...N ? {
		// this emits direct bytecode intructions
		new_obj := {}
		new_obj.x = 0
		new_obj.y = 1
		new_obj.z = 3
	}
	tookseconds := elf.get_performance_counter_elapsed_s(startcounter)
	elf.pf("hash-table per instance took: ", tookseconds)
}



#eof

elf.pf("main")
hash := elf.registryhash64(pathlist, "something")
elf.pf("hash: ", hash)

#eof
pathlist := elf.get_path_list(".", 100)
for p = pathlist[...] ? {
	elf.pf(p)
}



#eof
#eof


#eof
// elf.change_work_dir("play")
// load "visual_file_viewer.elf"
// #eof

#eof
// elf.create_process("notepad.exe")
file := elf.open_file("dummy_file.txt", "rb")
data := elf.read_file(file)
times := elf.get_file_times(file)
elf.pf(data)
elf.pf(elf.file_time_to_system_time(times.access))
#eof

elf.pf(formatted)
#eof
elf.change_work_dir("W:\\MicroRJ\\beatliner")
load "main.elf"
#eof

load "main.elf"
#eof


elf.change_work_dir("play")
load "physics.elf"
#eof


TAU ::= 6.283185307179586

InitWindow("Gait", 128, 128, 3)

random_color = fun() ? {
	--> { r = elf.random() * 255, g = elf.random() * 255, b = elf.random() * 255, a = 255 }
}

DrawThickLine = fun(x0, y0, x1, y1, thick, color) ? {
	sx := x1 - x0
	sy := y1 - y0
	l := sqrt(sx*sx + sy*sy)
	dx := sx / l
	dy := sy / l

	for i = 0...l ? {
		x := x0 + dx * i
		y := y0 + dy * i
		DrawCircle(x, y, thick, 1)
	}
}


Bird = {
	__new = fun() ? {

		head_r := 8 + elf.random() * 4
		body_r := 8 + elf.random() * 32

		feet_r := 1 + elf.random() * 4

		head_angle := TAU * 0.25 + elf.random() * TAU * 0.25
		neck_l := body_r + 10 + elf.random() * 20
		head_x := cos(head_angle) * neck_l
		head_y := sin(head_angle) * neck_l

		this.x = 64
		this.y = 64
		this.beak = { x = 0, y = 0, c = random_color() }
		this.head = { x = head_x, y = head_y, r = head_r, c = random_color() }
		this.body = { x = 0, y = 0, r = body_r, c = random_color() }
		this.lfoot = { x = 0, y = 0, r = feet_r, c = random_color() }
		this.rfoot = { x = 0, y = 0, r = feet_r, c = random_color() }
	}
	draw = fun() ? {
		SetColor(this.body.c.r, this.body.c.g, this.body.c.b, this.body.c.a)
		DrawCircle(this.x + this.body.x, this.y + this.body.y, this.body.r, 1)

		// BEAK
		SetColor(this.beak.c.r, this.beak.c.g, this.beak.c.b, this.beak.c.a)
		DrawTriangle(
		, this.x + this.head.x - this.head.r
		, this.y + this.head.y + 2

		, this.x + this.head.x - this.head.r - 10
		, this.y + this.head.y - 2

		, this.x + this.head.x - this.head.r
		, this.y + this.head.y - 4)

		// HEAD
		SetColor(this.head.c.r, this.head.c.g, this.head.c.b, this.head.c.a)
		DrawCircle(this.x + this.head.x, this.y + this.head.y, this.head.r, 1)

		// NECK
		DrawThickLine(
		,	this.x + this.head.x
		, 	this.y + this.head.y
		, 	this.x + this.body.x
		, 	this.y + this.body.y, this.head.r * 0.80)


		// EYE
		SetColor(255, 255, 255, 255)
		DrawCircle(this.x + this.head.x, this.y + this.head.y, this.head.r * 0.5, 1)
		SetColor(0, 0, 0, 255)
		DrawLine(this.x + this.head.x - 1, this.y + this.head.y + 0, this.x + this.head.x + 2, this.y + this.head.y + 0, 1)
		DrawLine(this.x + this.head.x + 0, this.y + this.head.y - 1, this.x + this.head.x + 0, this.y + this.head.y + 2, 1)


		SetColor(this.lfoot.c.r, this.lfoot.c.g, this.lfoot.c.b, this.lfoot.c.a)
		DrawCircle(this.x + this.lfoot.x, this.y + this.lfoot.y, this.lfoot.r, 1)

		DrawCircle(this.x + this.rfoot.x, this.y + this.rfoot.y, this.rfoot.r, 1)
	}
}

bird = nil
while PollWindow() ? {
	Clear()
	if Button('X') & 4 ? {
		bird = nil
	}
	bird ?= new Bird()
	bird:draw()
}



#eof
elf.change_work_dir("play")
load "Complex.elf"
#eof


InitWindow("Gait", 320, 180, 3)

mix = fun (t, a, b) ? {
	--> a + t * (b - a)
}

osc = fun (t) ? {
	--> sin(t * TAU) * 0.5 + 0.5
}

rot = fun (r, l) ? {
	--> {
		x = cos(r * TAU) * l,
		y = sin(r * TAU) * l
	}
}

t := 0
while PollWindow() ? {
	Clear()
	SetColor(255, 255, 255, 255)
	r  := 32
	e  := { x = 320 * 0.5, y = 180 * 0.5 }

	t = -0.25
	{
		SetColor(255, 255, 255, 128)
		DrawCircle(e.x, e.y, r, 4)

		k := mix(osc(t), 0, -0.25)
		p := rot(k, 32)
		px := e.x + p.x
		py := e.y + p.y

		SetColor(0, 0, 255, 255)
		DrawLine(e.x, e.y, px, py)

		SetColor(255, 0, 0, 255)
		DrawCircle(px, py, 4, 1)

		e.x = px
		e.y = py
	}

	{
		SetColor(255, 255, 255, 128)
		DrawCircle(e.x, e.y, r, 4)

		k := mix(osc(t), -0.25, 0)
		p := rot(k, 32)
		px := e.x + p.x
		py := e.y + p.y

		SetColor(0, 0, 255, 255)
		DrawLine(e.x, e.y, px, py)

		SetColor(255, 0, 0, 255)
		DrawCircle(px, py, 4, 1)

		e.x = px
		e.y = py
	}
	t += 0.01
}






#eof

elf.change_work_dir("play\\collision")
load "main.elf"
#eof


InitWindow("Square", 320 * 4, 180 * 4, 1)
LoadFont("C:\\Windows\\Fonts\\times.ttf")

abs = fun(x) ? {
	if x < 0 ? {
		--> - x
	}
	--> x
}

r0 = { x = 32, y = 32, w = 16, h = 16 }
r1 = { x = 64, y = 32, w = 32, h = 32 }


while PollWindow() ? {
	Clear()

	mx := (Button('D') & 1) - (Button('A') & 1)
	my := (Button('W') & 1) - (Button('S') & 1)

	r0.x += mx
	r0.y += my

	overlapping := false

	xd := r1.x - r0.x + (r1.w - r0.w) * 0.5
	yd := r1.y - r0.y + (r1.h - r0.h) * 0.5

	xp := abs(xd) - (r0.w + r1.w) * 0.5
	yp := abs(yd) - (r0.h + r1.h) * 0.5

	if xp < 0 && yp < 0 ? {
		overlapping = true
	}

	SolidFill()
	SetColor(255, 255, 255, 255)
	if overlapping ? {
		SetColor(255, 0, 0, 255)
	}
	// SetColor(0, 0, 255, 255)
	DrawRectangle(r0.x, r0.y, r0.w, r0.h)
	// SetColor(255, 0, 0, 255)
	DrawRectangle(r1.x, r1.y, r1.w, r1.h)

	SetColor(255, 255, 255, 255)
	DrawText(32, 512, "What Is Love")
}

#eof



#eof

InitWindow("Test!", 128, 128, 4)

time_start := elf.get_clock_time()

trim := fun(v) ? {
	if v < 0 ? v = 0
	else if v > 1 ? v = 1
	--> v
}

p := 32

while PollWindow() ? {
	Clear(0, 0, 0, 0)
	SetColor(32, 32, 32, 255)

	if Button('A') & 1 ? {
		p -= 1
	}
	if Button('D') & 1 ? {
		p += 1
	}

	for i = 0...1 ? {
		x := p + i * (32 + 8) + i
		w := 32 // * (0.4 + 0.6 * trim(1 - i / 4.0))
		h := 64 // * (0.4 + 0.6 * trim(1 - i / 4.0))
		y := 32 // 32 + 64 * 0.5 - h * 0.5
		DrawRectangle(x, y, w, h)
	}
}



// elf.change_work_dir("play\\graph")
// load "main.elf"

#eof



// file := elf.open_file("tests\\test.json", "rb")
// contents := elf.read_file(file)
expr := elf.load_expr("tests\\test.json")

// for name = expr:keys()[...] ? {
	// elf.pf(name)
// }

file := elf.open_file("tests\\generated_bindings.c", "wb")
defer elf.close_file(file)

// for i = expr.defines[...] ? {
// 	elf.fpf(file, "#define ", i.name, " ", i.value, "\n")
// }

// todo: #index
// i := 0
// if proto.params ? {
// 	for param = proto.params[...] ? {
// 		if i != 0 ? {
// 			elf.fpf(file, ", ")
// 		}
// 		elf.fpf(file, param.type, " ", param.name)
// 		i += 1
// 	}
// }

types_and_getter_functions := {
	{ type = "int"                 , getter = "GetInteger"  },
	{ type = "unsigned int"        , getter = "GetInteger"  },
	{ type = "bool"                , getter = "GetInteger"  },
	{ type = "const char *"        , getter = "GetText"     },
	{ type = "const unsigned char" , getter = "GetText"     },
	{ type = "char *"              , getter = "GetText"     },
	{ type = "float"               , getter = "GetNumber"   },
	{ type = "double"              , getter = "GetNumber"   },
}

types_to_getter := {}
for pair = types_and_getter_functions[...] ? {
	types_to_getter[pair.type] = pair.getter
}

for proto = expr.functions[...] ? {
	elf.fpf(file, "int L_", proto.name, "(elf_State *S) {\n")

	elf.fpf(file, "\tint result = 0;\n")

	if proto.params ? {
		i := 0
		for param = proto.params[...] ? {
			elf.fpf(file, "\t", param.type, " ", param.name, " = ")
			getter := types_to_getter[param.type] ?? "undefined"
			elf.fpf(file, getter, "(S, ", i, ");\n")
			i += 1
		}
	}

	elf.fpf(file, "\t")
	elf.fpf(file, proto.name, "(")
	{
		// todo: elf, use #index
		i := 0
		if proto.params ? {
			for param = proto.params[...] ? {
				if i != 0 ? {
					elf.fpf(file, ", ")
				}
				elf.fpf(file, param.name)
				i += 1
			}
		}
	}
	elf.fpf(file, ");\n")

	elf.fpf(file, "\treturn result;\n")

	elf.fpf(file, "}\n")
}




#eof
elf.change_work_dir("play")
load "rnd.elf"
elf.change_work_dir("grass")
load "main.elf"
#eof


N := 225
elf.pf(6 * (N - 1) * N / 2)
{
	a = 0
	for i = 0...225 ? {
		a += 4 + 6 * i
	}
	elf.pf("1: ", a)
}
#eof
{
	N ::= 225
	a = 0
	for i = 0...N ? {
		a += 6 * i
	}
	// a += 4 * N
	k = 6 * (N - 1) * N / 2
	elf.pf("2: ", a, ", ", k)
}
#eof










#eof


// this is the file elf looks for by default
elf.change_work_dir("play\\graph")
load "main.elf"
#eof


dot = fun(a, b) ? {
	--> a.x * b.x + a.y * b.y
}
length = fun(a) {
	--> sqrt(dot(a, a))
}
normalize = fun(a) ? {
	l := length(a)
	--> { x = a.x / l, y = a.y / l }
}

//
// 2x + -y = 0
// -x + 2y = 3
//
// x [ 2 ]  y [ -1 ] = [0]
// x [-1 ]  y [  2 ] = [3]
//
a = { x =  2, y = -1 }
b = { x = -1, y =  2 }
s = { x =  0, y =  3 }

d0 = dot(a, s)
d1 = dot(b, s)

elf.pf("dot: ", d0)
elf.pf("dot: ", d1)

#eof

elf.change_work_dir("C:\\work\\MicroRJ\\leap")
load "main.elf"
#eof

#eof

elf.pf(elf.const_expr("{0={0=1,1=2,2=3}}"))
elf.pf(elf.const_expr("7"))
elf.pf(elf.const_expr("7.0"))
elf.pf(elf.const_expr("{}"))
elf.pf(elf.const_expr("{1,2,3}"))
elf.pf(elf.const_expr("{0=1,1=2,2=3}"))
#eof
b := 0 || 1
elf.flags(1<<3)
elf.pf("0 && b: ", 7 && b)
#eof


#eof

test_and = fun(a,b) ? {
	if a ? { if b ? { --> true } }
	--> false
}
test_or = fun(a,b) ? {
	if a ? { --> true }
	if b ? { --> true }
	--> false
}
operators = {{"&&",test_and},{"||",test_or}}

generate_test_expr = fun(a,b,level) ? {
	if level > 3 ? {
		--> a
	}
	text := "(" + generate_test_expr(a,0,level+1) + " " + operators:idx(0,0) + " " + generate_test_expr(b,1,level+1) + ")"

	--> text
}

text := generate_test_expr(1,0,0)
elf.pf(text)

#eof


table = {}
for i = 0...10 ? {
	table[i] = i
}
elf.pf(table)
for i = 0...10 ? {
	elf.pf("deleting: ", i)
	elf.pf("before: ")
	elf.pf(table:keys())
	table:delete(i)
	elf.pf("after: ")
	elf.pf(table:keys())
}
#eof

test_table := {
	__new = fun() ? {}
}
xxx := test_table.__new
elf.flags(1<<3)
xxx("HERE")

#eof
elf.change_work_dir("play")
load "collision.elf"
#eof
elf.flags(1<<3)
expr ::= elf.load_expr("test_expr.elf")
elf.pf(expr)
#eof
load "worm.elf"
#eof


load "tests\\overload.elf"
#eof
load "tests\\if.elf"
load "tests\\fun.elf"
load "tests\\loops.elf"
load "tests\\prec.elf"

