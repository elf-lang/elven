MATH ::= {
	PI   	= 3.14159,
	TAU  	= 6.28318,
	E  	= 2.71828,
}
WHITE = {r=255,g=255,b=255,a=255}
BLUE  = {r=32,g=32,b=200,a=255}
GREEN = {r=0,g=128,b=32,a=255}
RED   = {r=255,g=32,b=0,a=255}

UPSCALE  	::= 2
WIND_W   	::= 320
WIND_H   	::= 240
ASPECT_R 	::= WIND_W / iton(WIND_H)
CENTER_X 	::= WIND_W / 2
CENTER_Y 	::= WIND_H / 2

VIEW ::= new elf.gfx.Window("Collision!",WIND_W,WIND_H,UPSCALE)
PRESSED  = elf.gfx.Window.PRESSED
DOWN 		= elf.gfx.Window.DOWN
RELEASED = elf.gfx.Window.RELEASED
INITIAL_OFFSET ::= {
	// x=CENTER_X,
	// y=CENTER_Y

	x=0,
	y=WIND_H
}
VIEW.ofs = INITIAL_OFFSET:clone()
VIEW.Z   = 1.0

Rect = {
	__new = fun(x,y,w,h,c) ? {
		this.x=x
		this.y=y
		this.w=w
		this.h=h
		this.c=c ?? WHITE
	}
	test = fun() ? {
		if (new Rect(0,0,1,1)):overlaps(new Rect(0,1,1,1)) ? {
			elf.pf("Rect Is Wrong!")
		}
		if (new Rect(0,0,1,1)):overlaps(new Rect(1,0,1,1)) ? {
			elf.pf("Rect Is Wrong!")
		}
	}
	overlaps = fun(that) ? {
		--> this.x + this.w > that.x
		&&  this.y + this.h > that.y
		&&  that.x + that.w > this.x
		&&  that.y + that.h > this.y
	}

	move_and_collide = fun(move,get_rects) ? {
		for i = 0,1 ? {
			if i == 0 ? this.x += move.x;
			else 			this.y += move.y;
			check_rects ::= get_rects(this)
			for that = check_rects[...] ? {
				this.colliding = true
				that.colliding = true
				if i == 0 ? {
					if this.x < that.x ? this.x = that.x - this.w;
					else           		this.x = that.x + that.w;
					this.velocity.x = 0
				} else {
					if this.y < that.y ? this.y = that.y - this.h;
					else           		this.y = that.y + that.h;
					this.velocity.y = 0
				}
			}
		}
	}
	draw = fun() ? {
		c := this.c
		if this.colliding ? {
			c = RED
		}
		VIEW:draw_rect(
		, VIEW.ofs.x + this.x
		, VIEW.ofs.y - this.y - this.h
		, this.w * VIEW.Z
		, this.h * VIEW.Z
		, c.r,c.g,c.b,c.a)
	}
}

BLOCK_SIZE = 16

Player = new Rect(0,BLOCK_SIZE,8,15)
Player.velocity = {x=0,y=0}
rects = {}
rects:add(Player)

get_overlapping_rects = fun(that) ? {
	results ::= {}
	for rect = rects[...] ? {
		if rect != that ? {
			if rect:overlaps(that) ? {
				results:add(rect)
			}
		}
	}
	--> results
	// #worstbugever
	// omg, for some reason instead of using
	// a range, we  use a step, -1,0,2 will
	// trigger the most weird fatal bug ever,
	// please look into it, seems that also
	// the bug goes away if we keep steps but
	// we remove the if statement ofs_x == 0,
	// it has to do with ofs_x, because the
	// if statement can remain just not us
	// checking ofs
	for ofs_y = -1...2 ? {
		for ofs_x = -1...2 ? {
			if ofs_x == 0 && ofs_y == 0 ? {
				continue
			}
			tile_x ::= ntoi(floor(ofs_x + that.x / BLOCK_SIZE))
			tile_y ::= ntoi(floor(ofs_y + that.y / BLOCK_SIZE))
			key ::= tile_y << 16 | tile_x
			if rects[key] ? {
				if that:overlaps(rects[key]) ? {
					results:add(rects[key])
				}
			}
		}
	}
	--> results
}


coords_to_tile ::= fun(x,y) ? {
	tile_x ::= ntoi(floor(x / BLOCK_SIZE))
	tile_y ::= ntoi(floor(y / BLOCK_SIZE))
	key ::= tile_y << 16 | tile_x
	if tile_y >> 16 ? {
		elf.pf("invalid tile coordinates, too large: x,y = ", x, ", ", y)
		--> nil
	} else {
		--> {key=key,tile_x=tile_x,tile_y=tile_y}
	}
}
unplace_rect ::= fun(x,y) ? {
	info ::= coords_to_tile(x,y)
	tile_x ::= info.tile_x
	tile_y ::= info.tile_y
	key ::= info.key
	if rects[key] ? {
		rects:delete(key)
		// rects[key] = nil
	}
}
place_rect ::= fun(x,y) ? {
	info ::= coords_to_tile(x,y)
	if info ? {
		tile_x ::= info.tile_x
		tile_y ::= info.tile_y
		key ::= info.key
		rects[key] ?= new Rect(
		,	tile_x * BLOCK_SIZE
		,	tile_y * BLOCK_SIZE
		,	BLOCK_SIZE
		,	BLOCK_SIZE
		)
	}
}

for i = 0...10 ? {
	place_rect(i*BLOCK_SIZE,0)
}
// rects:add(new Rect(10*BLOCK_SIZE,CENTER_Y-BLOCK_SIZE*0.5,10*BLOCK_SIZE,BLOCK_SIZE, GREEN))
// rects:add(new Rect(0,CENTER_Y-BLOCK_SIZE*0.5,10*BLOCK_SIZE,BLOCK_SIZE, BLUE))

total_time = 0

platforms := {}
platforms:add(new Rect(32,32,32,8))
platforms:add(new Rect(64,32,32,8))
allow_jump = false

tick_platforms := fun(time) ? {

	for platform = platforms[...] ? {
		move := {
			x=cos(total_time*0.1)*0.1
			y=sin(total_time*0.1)*0.1
		}
		platform.y += move.y
		platform.x += move.x
		check_rects := {}
		if Player:overlaps(platform) ? {
			check_rects:add(Player)
		}
		for that = check_rects[...] ? {
			platform.colliding = true
			that.colliding = true
			if platform.y < that.y ? {
				if that.velocity.y < 0 ? {
					that.y = platform.y + platform.h;
					that.velocity.y = 0
					that.x += move.x
					allow_jump = true
				}
			}
		}
	}
}

while VIEW:poll() ? {
	time ::= VIEW.time

	Player.velocity.y -= 10 * time
	if VIEW.keys['W'] & PRESSED ? {
		Player.velocity.y = 4
	}
	// if VIEW.keys['S'] & DOWN ? { Player.velocity.y += 5 * time };
	// if VIEW.keys['A'] & DOWN ? { Player.velocity.x -= 5 * time };
	// if VIEW.keys['D'] & DOWN ? { Player.velocity.x += 5 * time };
	// Player.velocity.y -= Player.velocity.y * 1 * time
	// Player.velocity.x -= Player.velocity.x * 1 * time

	move ::= Player.velocity:clone()
	// if VIEW.keys['S'] & DOWN ? move.y -= 2;
	if VIEW.keys['A'] & DOWN ? move.x -= 2;
	if VIEW.keys['D'] & DOWN ? move.x += 2;

	mouse_in_view_x ::= (VIEW.mouse_x - VIEW.ofs.x) / VIEW.Z
	mouse_in_view_y ::= (VIEW.ofs.y - VIEW.mouse_y) / VIEW.Z
	// elf.pf(mouse_in_view_x, ", ", mouse_in_view_y)

	if VIEW.mouse[1] & DOWN ? {
		place_rect(mouse_in_view_x,mouse_in_view_y)
	}
	if VIEW.mouse[2] & DOWN ? {
		unplace_rect(mouse_in_view_x,mouse_in_view_y)
	}

	for a = platforms[...],rects[...] ? {
		a.colliding = false
	}

	a ::= Player
	Player:move_and_collide(move,get_overlapping_rects)

	tick_platforms(time)

	for r = rects[...], platforms[...] ? {
		r:draw()
	}

	total_time += time
}