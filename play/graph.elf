// global_prefix "${elf.get_unique_file_id()}" as file

MATH ::= {
	PI   	= 3.14159,
	TAU  	= 6.28318,
	E  	= 2.71828,
}

max := fun(a,b) ? { if a > b ? --> a else --> b }
min := fun(a,b) ? { if a < b ? --> a else --> b }

UPSCALE  	::= 2
WIND_W   	::= 320
WIND_H   	::= 240
UNIT 			::= 8
ASPECT_R 	::= WIND_W / iton(WIND_H)
CENTER_X 	::= WIND_W / 2
CENTER_Y 	::= WIND_H / 2
CELL 			::= UNIT

_rgb = fun(r,g,b,a) ? ({r=r,g=g,b=b,a=a??255})

VIEW ::= new elf.gfx.Window("Graph!",WIND_W,WIND_H,UPSCALE)
PRESSED  = elf.gfx.Window.PRESSED
DOWN 		= elf.gfx.Window.DOWN
RELEASED = elf.gfx.Window.RELEASED
INITIAL_OFFSET ::= {
	x=CENTER_X,
	y=CENTER_Y
}
VIEW.ofs = INITIAL_OFFSET:clone()
VIEW.Z   = 1.0

zoom_in_at_mouse ::= fun(by) ? {
	by ?= 0.01
	new_scale ::= VIEW.Z + VIEW.Z * by
	if new_scale <= 0 ? {
		ret
	}

	mouse_x ::= VIEW.mouse_x
	mouse_y ::= VIEW.mouse_y

	a ::= VIEW.Z / new_scale
	if a != 0 ? {
		VIEW.ofs.x = mouse_x - (mouse_x - VIEW.ofs.x) / a
		VIEW.ofs.y = mouse_y - (mouse_y - VIEW.ofs.y) / a
		VIEW.Z = new_scale
	}
}

draw_grid ::= fun() ? {
	scale 		::= VIEW.Z
	cell_size   ::= CELL * scale
	grid_size_x ::= WIND_W / cell_size + 1
	grid_size_y ::= WIND_H / cell_size + 1

	VIEW:set_color(255,255,255,255*0.25)
	for y = 0...grid_size_y ? {
		VIEW:draw_rect(0,VIEW.ofs.y%cell_size+y*cell_size,WIND_W,1)
	}
	for x = 0...grid_size_x ? {
		VIEW:draw_rect(VIEW.ofs.x%cell_size+x*cell_size,0,1,WIND_H)
	}
	VIEW:set_color(255,0,0,255*0.80)
	VIEW:draw_rect(VIEW.ofs.x,0,1,WIND_H)
	VIEW:set_color(0,255,0,255*0.80)
	VIEW:draw_rect(0,VIEW.ofs.y,WIND_W,1)
}

global name ?= 1


offset_minus_mouse := {x=0,y=0}
user_input ::= fun() ? {

	if VIEW.keys['Z'] & DOWN ? { zoom_in_at_mouse(0.01) }
	if VIEW.keys['X'] & DOWN ? { zoom_in_at_mouse(-0.01) }
	if VIEW.keys['W'] & DOWN ? { VIEW.ofs.y -= 1 }
	if VIEW.keys['S'] & DOWN ? { VIEW.ofs.y += 1 }
	if VIEW.keys['A'] & DOWN ? { VIEW.ofs.x -= 1 }
	if VIEW.keys['D'] & DOWN ? { VIEW.ofs.x += 1 }
	if VIEW.keys['R'] & DOWN ? {
		VIEW.ofs = INITIAL_OFFSET:clone()
		VIEW.Z   = 1.0
	}

	mouse_x ::= VIEW.mouse_x
	mouse_y ::= VIEW.mouse_y
	if VIEW.mouse[1] & PRESSED ? {
		dragging = true
		offset_minus_mouse.x = VIEW.ofs.x - mouse_x
		offset_minus_mouse.y = VIEW.ofs.y - mouse_y
	}
	if VIEW.mouse[1] & DOWN ? {
		if dragging ? {
			VIEW.ofs.x = offset_minus_mouse.x + mouse_x
			VIEW.ofs.y = offset_minus_mouse.y + mouse_y
		}
	}
}

while VIEW:poll() ? {
	user_input()

	draw_grid()
	Z ::= VIEW.Z

	force_radius := 8.0
	force_dropoff := 16.0
	sources := {
		{
			c = _rgb(255,255,0)
			f = fun(x) ? {
				if x < force_radius ? {
					--> 2
				} else {
					--> 1 - min((x - force_radius) / force_dropoff, 1.0)
				}
			},
		},
		{
			f = fun(x) ? {
				if x < 2 ? {
					--> 4
				} else {
					--> 4+1 - x / 2
				}
			},
			c = _rgb(255,0,255)
		},
	}
	old := {
		{
			f = fun(x) ? (x),
			c = _rgb(255,255,0)
		},
		{
			f = fun(x) ? (x * x * x),
			c = _rgb(0,255,255)
		},
		{
			f = fun(x) ? sin(x)
			c = _rgb(64,64,255)
		},
		{
			f = fun(x) ? 1.0 / (0.1 + x)
			c = _rgb(64,64,255)
		},
		{
			f = fun(x) ? pow(MATH.E,x)
			c = _rgb(64,64,255)
		}
	}

	// todo: instead of sampling this way,
	// we should sample starting at the
	// origin moving away in both directions,
	// that way we can stop sampling once we
	// go outside the screen
	for src = sources[...] ? {
		f ::= src.f
		c ::= src.c
		VIEW:set_color(c.r,c.g,c.b,c.a)
		// sample in screen space, number of samples
		// remains the same regardless of the scale
		for p = 0...WIND_W ? {
			xv ::= p - VIEW.ofs.x
			x0 ::= (xv + 0) / Z
			x1 ::= (xv + 1) / Z
			y0 ::= f(x0 / UNIT) * UNIT
			y1 ::= f(x1 / UNIT) * UNIT
			ddx := 0
			if (y1 - y0) != 0 ? {
				ddx = (x1 - x0) / (y1 - y0)
			}
			sy0 := VIEW.ofs.y - y0 * Z
			sy1 := VIEW.ofs.y - y1 * Z
			// window space clipping
			// todo: clipping should depend on the slope,
			// like if we're going up then x0 will be on
			// the bottom... y1 on top and vice versa.
			// also when we get really steep functions
			// the lines would be huge...
			if sy0 < 0 || sy0 > WIND_H ? {
				continue
			}
			if sy1 < 0 ? {
				sy1 = 0
			}
			// todo: figure out how to make this more efficient...
			VIEW:draw_line((p+0),sy0,(p+1),sy1)
		}
	}
}